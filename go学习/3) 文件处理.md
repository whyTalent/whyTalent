参考：http://c.biancheng.net/golang/102/ 

 

## 1 JSON文件

Go语言内建对 JSON 的支持，使用内置的 encoding/json 标准库，开发人员可以轻松使用Go程序生成和解析 JSON 格式的数据。

```go
func WriteJson(filename string, infos []Website) {
	// 创建文件
	filePtr, err := os.Create(filename)
	if err != nil {
		fmt.Println("json文件创建失败", err.Error())
		return
	}

	defer filePtr.Close()

	// 创建Json编码器
	enc := json.NewEncoder(filePtr)
	if err = enc.Encode(infos); err != nil {
		fmt.Println("json编码错误", err.Error())
	}

	fmt.Println("json编码成功")
}

func ReadJson(filename string) []Website {
	// 打开文件
	filePtr, err := os.Open(filename)
	if err != nil {
		fmt.Printf("json文件打开失败 [Err:%s]\n", err.Error())
		return nil
	}

	defer filePtr.Close()

	var infos []Website
	dec := json.NewDecoder(filePtr)
	if err = dec.Decode(&infos); err != nil {
		fmt.Printf("json解码失败 [Err:%s]\n", err.Error())
		return nil
	}
	fmt.Println("json解码成功")

	return infos
}
```

 

## 2 Xml文件

Go语言内置的 encoding/xml 包可以用在结构体和 XML 格式之间进行编解码，其方式跟 encoding/json 包类似。然而与 JSON 相比 XML 的编码和解码在功能上更苛刻得多，这是由于 encoding/xml 包要求结构体的字段包含格式合理的标签，而 JSON 格式却不需要。

```go
type Website struct {
	Name   string `xml:"name,attr"`
	Url    string
	Course []string
}

func WriteXml(filename string, infos []Website) {
	// 创建文件
	filePtr, err := os.Create(filename)
	if err != nil {
		fmt.Println("xml文件创建失败", err.Error())
		return
	}

	defer filePtr.Close()

	// 创建Json编码器
	enc := xml.NewEncoder(filePtr)
	if err = enc.Encode(infos); err != nil {
		fmt.Println("xml编码错误", err.Error())
	}

	fmt.Println("xml编码成功")
}

func ReadXml(filename string) []Website {
	// 打开文件
	filePtr, err := os.Open(filename)
	if err != nil {
		fmt.Printf("文件打开失败 [Err:%s]\n", err.Error())
		return nil
	}

	defer filePtr.Close()

	var infos []Website
	dec := xml.NewDecoder(filePtr)
	if err = dec.Decode(&infos); err != nil {
		fmt.Printf("解码失败 [Err:%s]\n", err.Error())
		return nil
	}
	fmt.Println("解码成功")

	return infos
}
```

xml 包还支持更为复杂的标签，包括嵌套。例如标签名为 'xml:"Books>Author"' 产生的是 <Books><Author>content</Author></Books> 这样的 XML 内容。同时除了 'xml:", attr"' 之外，该包还支持 'xml:",chardata"' 这样的标签表示将该字段当做字符数据来写，支持 'xml:",innerxml"' 这样的标签表示按照字面量来写该字段，以及 'xml:",comment"' 这样的标签表示将该字段当做 XML 注释。因此，通过使用标签化的结构体，我们可以充分利用好这些方便的编码解码函数，同时合理控制如何读写 XML 数据。

 

## 3 纯文本文件

Go语言提供了很多文件操作的支持，在不同场景下，有对应的处理方式。

```go
func WriteFile(filename string, infos []string) {
	// 创建文件
	filePtr, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		fmt.Println("文件创建失败", err.Error())
		return
	}

	defer filePtr.Close()

	//写入时，使用带缓存的 *Writer
	writer := bufio.NewWriter(filePtr)
	for i := 0; i < len(infos); i++ {
		writer.WriteString(infos[i] + "\n")
	}

	// 因为 writer 是带缓存的，因此在调用 WriterString 方法时，内容是先写入缓存的
	// 所以要调用 flush方法，将缓存的数据真正写入到文件中。
	writer.Flush()
}

func ReadFile(filename string) []string {
	// 打开文件
	filePtr, err := os.Open(filename)
	if err != nil {
		fmt.Printf("文件打开失败 [Err:%s]\n", err.Error())
		return nil
	}

	defer filePtr.Close()

	var infos []string
	//创建一个 *Reader ， 是带缓冲的
	reader := bufio.NewReader(filePtr)
	for {
		// 读到一个换行就结束
		str, err := reader.ReadString('\n')
		if err == io.EOF { // io.EOF 表示文件的末尾
			break
		}

		infos = append(infos, strings.Split(str, "\n")[0])
	}

	fmt.Println("文件读取结束...")

	return infos
}
```

 

## 4 zip文件

Go语言的标准库提供了对几种压缩格式的支持，其中包括 gzip，因此 Go 程序可以无缝地读写 .gz 扩展名的 gzip 压缩文件或非 .gz 扩展名的非压缩文件。此外标准库也提供了读和写 .zip 文件、tar 包文件（.tar 和 .tar.gz），以及读 .bz2 文件（即 .tar .bz2 文件）的功能。

```go
func WriteZip(filename string, infos []Zfile) {
	// step1: 创建一个缓冲区用来保存压缩文件内容
	buf := new(bytes.Buffer)

	// step2: 创建一个压缩文档
	w := zip.NewWriter(buf)
	// step3: 将文件加入压缩文档
	for _, file := range infos {
		// step3-1: 创建zip压缩文档
		f, err := w.Create(file.Name)
		if err != nil {
			fmt.Println("zip文档创建失败: ", err.Error())
			continue
		}

		// step3-2: 写入数据
		_, err = f.Write([]byte(file.Body))
		if err != nil {
			fmt.Println("zip文档写入失败: ", err.Error())
		}
	}

	// step4: 关闭压缩文档
	err := w.Close()
	if err != nil {
		fmt.Println("zip文档关闭失败: ", err.Error())
		return
	}

	// step5: 将压缩文档内容写入文件
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY, 0666)
	if err != nil {
		fmt.Println("压缩文档内容写入文件失败: ", err.Error())
		return
	}
	buf.WriteTo(f)
}

func ReadZip(filename string) {
	// 打开一个zip格式文件
	r, err := zip.OpenReader(filename)
	if err != nil {
		fmt.Printf("zip文档创建失败: ", err.Error())
	}
	defer r.Close()

	// 迭代压缩文件中的文件，打印出文件中的内容
	for _, f := range r.File {
		fmt.Printf("文件名: %s\n", f.Name)
		rc, err := f.Open()
		if err != nil {
			fmt.Printf(err.Error())
		}

		_, err = io.CopyN(os.Stdout, rc, int64(f.UncompressedSize64))
		if err != nil {
			fmt.Printf(err.Error())
		}
		rc.Close()
	}
}
```

  

## 5 二进制文件

Go语言的二进制（gob）格式是一个自描述的二进制序列。从其内部表示来看，Go语言的二进制格式由一个 0 块或者更多块的序列组成，其中的每一块都包含一个字节数，一个由 0 个或者多个 typeId-typeSpecification 对组成的序列，以及一个 typeId-value 对。

如果 typeId-value 对的 typeId 是预先定义好的（例如 bool、int 和 string 等），则这些 typeId-typeSpecification 对可以省略，否则就用类型对来描述一个自定义类型（如一个自定义的结构体），其中类型对和值对之间的 typeId 没有区别。

Go语言中的 encoding/gob 包也提供了与 encoding/json 包一样的编码解码功能，并且容易使用。通常而言如果对肉眼可读性不做要求，gob 格式是Go语言上用于文件存储和网络传输最为方便的格式。

```go
func WriteGob(filename string, info string) {
	f, err := os.Create(filename)
	if err != nil {
		fmt.Println("文件创建失败", err.Error())
		return
	}

	defer f.Close()

	encoder := gob.NewEncoder(f)
	err = encoder.Encode(info)
	if err != nil {
		fmt.Println("gob编码错误", err.Error())
		return
	}

	fmt.Println("gob编码成功")
}

func ReadGob(filename string) string {
	// 打开文件
	filePtr, err := os.Open(filename)
	if err != nil {
		fmt.Printf("json文件打开失败 [Err:%s]\n", err.Error())
		return nil
	}

	defer filePtr.Close()

	var info string
	dec := gob.NewDecoder(filePtr)
	if err = dec.Decode(&info); err != nil {
		fmt.Printf("gob解码失败 [Err:%s]\n", err.Error())
		return ""
	}
	fmt.Println("gob解码成功")

	return info
}
```

  

## 6 buffer读写文件

buffer 是缓冲器的意思，Go语言要实现缓冲读取需要使用到 bufio 包。bufio 包本身包装了 io.Reader 和 io.Writer 对象，同时创建了另外的 Reader 和 Writer 对象，因此对于文本 I/O 来说，bufio 包提供了一定的便利性。

buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。

  

### 1）写文件

bufio 和 io 包中有很多操作都是相似的，唯一不同的地方是 bufio 提供了一些缓冲的操作，如果对文件 I/O 操作比较频繁的，使用 bufio 包能够提高一定的性能。在 bufio 包中，有一个 Writer 结构体，而其相关的方法支持一些写入操作

```go
//Writer 是一个空的结构体，一般需要使用 NewWriter 或者 NewWriterSize 来初始化一个结构体对象
type Writer struct {
        // contains filtered or unexported fields
}

//NewWriterSize 和 NewWriter 函数
//返回默认缓冲大小的 Writer 对象(默认是4096)
func NewWriter(w io.Writer) *Writer
//指定缓冲大小创建一个 Writer 对象
func NewWriterSize(w io.Writer, size int) *Writer

//Writer 对象相关的写入数据的方法
//把 p 中的内容写入 buffer，返回写入的字节数和错误信息。如果 nn < len(p)，返回错误信息中会包含为什么写入的数据比较短
func (b *Writer) Write(p []byte) (nn int, err error)
//将 buffer 中的数据写入 io.Writer
func (b *Writer) Flush() error

//以下三个方法可以直接写入到文件中
//写入单个字节
func (b *Writer) WriteByte(c byte) error
//写入单个 Unicode 指针返回写入字节数错误信息
func (b *Writer) WriteRune(r rune) (size int, err error)
//写入字符串并返回写入字节数和错误信息
func (b *Writer) WriteString(s string) (int, error)
```

  

示例：

```go

func main() {
    name := "demo.txt"
    content := "http://c.biancheng.net/golang/"
  	
    fileObj, err := os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)
    if err != nil {
        fmt.Println("文件打开失败", err)
    }
    defer fileObj.Close()
    writeObj := bufio.NewWriterSize(fileObj, 4096)
  	
    //使用 Write 方法,需要使用 Writer 对象的 Flush 方法将 buffer 中的数据刷到磁盘
    buf := []byte(content)
    if _, err := writeObj.Write(buf); err == nil {
        if err := writeObj.Flush(); err != nil {
            panic(err)
        }
        fmt.Println("数据写入成功")
    }
}
```

 

### 2）读文件

bufio 包的相关的 Reader 函数方法：

```go
//首先定义了一个用来缓冲 io.Reader 对象的结构体，同时该结构体拥有以下相关的方法
type Reader struct {
}

//NewReader 函数用来返回一个默认大小 buffer 的 Reader 对象（默认大小是 4096） 等同于 NewReaderSize(rd,4096)
func NewReader(rd io.Reader) *Reader
//该函数返回一个指定大小 buffer（size 最小为 16）的 Reader 对象，如果 io.Reader 参数已经是一个足够大的 Reader，它将返回该 Reader
func NewReaderSize(rd io.Reader, size int) *Reader

//该方法返回从当前 buffer 中能被读到的字节数
func (b *Reader) Buffered() int
//Discard 方法跳过后续的 n 个字节的数据，返回跳过的字节数。如果 0 <= n <= b.Buffered()，该方法将不会从 io.Reader 中成功读取数据
func (b *Reader) Discard(n int) (discarded int, err error)
//Peekf 方法返回缓存的一个切片，该切片只包含缓存中的前 n 个字节的数据
func (b *Reader) Peek(n int) ([]byte, error)

//返回单个字节，如果没有数据返回 err
func (b *Reader) ReadByte() (byte, error)
//该方法在 b 中读取 delimz 之前的所有数据，返回的切片是已读出的数据的引用，切片中的数据在下一次的读取操作之前是有效的。如果未找到 delim，将返回查找结果并返回 nil 空值。因为缓存的数据可能被下一次的读写操作修改，因此一般使用 ReadBytes 或者 ReadString，他们返回的都是数据拷贝
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
//功能同 ReadSlice，返回数据的拷贝
func (b *Reader) ReadBytes(delim byte) ([]byte, error)
//功能同 ReadBytes，返回字符串
func (b *Reader) ReadString(delim byte) (string, error)
//该方法是一个低水平的读取方式，一般建议使用 ReadBytes('\n') 或 ReadString('\n')，或者使用一个 Scanner 来代替。ReadLine 通过调用 ReadSlice 方法实现，返回的也是缓存的切片，用于读取一行数据，不包括行尾标记（\n 或 \r\n）
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)
//读取单个 UTF-8 字符并返回一个 rune 和字节大小
func (b *Reader) ReadRune() (r rune, size int, err error)
```

  

示例：

```go
func main() {
    fileObj, err := os.Open("demo.txt")
    if err != nil {
        fmt.Println("文件打开失败：", err)
        return
    }
    defer fileObj.Close()
  	
    //一个文件对象本身是实现了io.Reader的 使用bufio.NewReader去初始化一个Reader对象，存在buffer中的，读取一次就会被清空
    reader := bufio.NewReader(fileObj)
    buf := make([]byte, 1024)
    
    //读取 Reader 对象中的内容到 []byte 类型的 buf 中
    info, err := reader.Read(buf)
    if err != nil {
        fmt.Println(err)
    }
  	
    fmt.Println("读取的字节数:" + strconv.Itoa(info))
    //这里的buf是一个[]byte，因此如果需要只输出内容，仍然需要将文件内容的换行符替换掉
    fmt.Println("读取的文件内容:", string(buf))
}
```

 

## 7 OpenFile 函数

Go语言文件的写入、追加、读取、复制操作

```go
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

其中 name 是文件的文件名，如果不是在当前路径下运行需要加上具体路径；flag 是文件的处理参数，为 int 类型，根据系统的不同具体值可能有所不同，但是作用是相同的：

- O_RDONLY：只读模式打开文件；
- O_WRONLY：只写模式打开文件；
- O_RDWR：读写模式打开文件；
- O_APPEND：写操作时将数据附加到文件尾部（追加）；
- O_CREATE：如果不存在将创建一个新文件；
- O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；
- O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；
- O_TRUNC：如果可能，在打开时清空文件

