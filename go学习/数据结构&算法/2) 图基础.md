# 图结构

​       

图(Graph)是由顶点集合和一些顶点间的连线组成的数据结构，通常可以用 G(V, E)来表示。其中顶点集合**（Vertext Set）**和边的集合**（Edge Set）**分别用 V(G)和 E(G)表示。V(G)中的元素称为顶点（vertex），用 u、v 等符号表示。E(G)中的元素称为边（edge），用 e 等符号表示。

<div align="center"><img src="imgs/pic.png" alt="pic" style="zoom:80%;" /></div>

图 1(a) 所示的图可以表示为 G1(V, E)，其中顶点集合 V={1,2,3,4,5,6}，边集合 E={(1,2), (1,3), (2,3), (2,4), (2,5), (2,6), (3,4), (3,5), (4,5)}，这样的图叫 **无向图**，边(u,v)和(v,u)是同一条 边。而图 1(b) 所示的图是 **有向图**，有向边<u,v>中 u 为起点，v 为终点。

如果无向图中任何一对顶点之间都有一条边，这样的图称为 **完全图**。在完全图中，顶点 数 m 和边数 n 的关系为:**m=n**×**(n-1)/2**。边的数目相对较少的图称为 **稀疏图**，边的数目相对较多的图称为 **稠密图**。

<div align="center"><img src="imgs/pic2.png" alt="pic2" style="zoom:80%;" /></div>

在无向图中，如果(u,v)是图中的一条无向边，则称顶点 u 和顶点 v 互为邻接顶点，或称 (u,v)与顶点 u 和 v 相关联。

**顶点度数**：

* 无向图：一个顶点 u 的度数是与它相关联的边的数目，记为 **deg(u)**
* 有向图：顶点的度数等于该顶点的出度与入度之和，其中顶点 u 的出度是以 u 为起始顶点的有向边 （即从顶点 u 出发的有向边）的数目，记为 **od(u)**；而顶点 u 的入度是以 u 为终点的有向边（即 进入到顶点 u 的有向边）的数目，记为 **id(u)**，所以顶点 u 的度数：**deg(u) = od(u) + id(u)**

> 定理：**在无向图和有向图中，所有顶点度数总和，等于边数的两倍**

​       

# 一 基础

## 1. 图的连通性

在无向图中，如果从顶点 *u* 到 *v* 有路径，则称为顶点 u 和 v 是连通的。如果无向图中任意一对顶点都是连通的，则称此图为 **连通图**。相反，如果一个无向图不是连通图，则称为**非连通图**。

<div align="center"><img src="imgs/pic3.png" alt="pic3" style="zoom:80%;" /></div>

如果一个无向图不是连通的，则其极大连通子图称为 **连通分量**，这里的极大是指子图中包含的顶点个数极大，例如图中所示的无向图就是非连通图。其中，顶点 0,1,2,3 和 4 构成一个连通分量，顶点 5,6,7 构成另一个连通分量。

在有向图中，若对每一对顶点 u 和 v，即存在从 u 到 v 的路径，也存在从 v 到 u 的路径，则称此图为 **强连通图**。对于非强连通图，其极大强连通子图称为其 **强连通分量**。

某些图的边具有与它相关的数，称为权值。这些权值可以表示一个顶点到另一个顶点的 距离、花费的代价、所需的时间等等。如果一个图，其所有边都具有权值，则称为 **加权图**， 或者称为 **网络(net)**。

​      

## 2. 存储结构

 图的存储结构主要有四种:

* 邻接矩阵（使用二维数组存储，不推荐使用）
* 邻接表
* 前向星
* 链式前向星（静态建表） 

在编写程序中，后三种是我们经常采用的图的存储结构

​    

### 1）邻接矩阵

图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。

**无向图**

顶点数组为vertex[4]={v0,v1,v2,v3}，边数组arc[4]\[4]为下图右边这样的一个矩阵。对于矩阵的主对角线的值，即arc[0]\[0]、arc[1]\[1]、arc[2]\[2]、arc[3]\[3]，全为0是因为不存在顶点的边。

<div align="center"><img src="imgs/pic4.png" alt="pic4" style="zoom:80%;" /></div>

**有向图**

如下图所示的左边，顶点数组为vertex[4]={v0,v1,v2,v3}，弧数组arc[4]\[4]为下图右边这样的一个矩阵，主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称，比如由v1到v0有弧，得到arc[1]\[0]=1，而v到v没有弧，因此arc[0]\[1]=0。

<div align="center"><img src="imgs/pic5.png" alt="pic5" style="zoom:80%;" /></div>

**注意**：如果图中存在**自身环**（连接某个顶点自身的边）和**重边**，多条边的起点一样，终点也一样，也称为平行边的情况，则无法使用邻接矩阵存储。

**优缺点**：

* 可直接查询点i和点j之间是否有边；
* 遍历效率低，不能存储重编；
* 初始化效率低；
* 大图开销大，适合存储点少的稠密图

​      

### 2）邻接表

邻接表是一种链式的存储结构，对于图 G 中的每个顶点 Vi，所有邻接于 *Vi* 顶点 *Vj* 链成一个单链表，这个单链表称为顶点 *Vi* 的邻接表。 

邻接表中每个表节点有三个属性

> A. 邻接点序号 to，用以存放与顶点 Vi 相邻接的顶点 vj 的序号 j；
>
> B. 边上的权值；
>
> C. 指针 next，用来将邻接表的所有节点链在一 起；

另外，每个顶点 **Vi** 的邻接表设置一个具有两个属性的表头节点，一个是顶点序号 from， 另一个是指向其邻接表的指针 **first**，它是指向 Vi 的邻接表的第一个节点的指针。建立一个 Vnode 的数组就可以访问每个顶点的邻接表了。

**无向图**

<div align="center"><img src="imgs/pic6.png" alt="pic6" style="zoom:80%;" /></div>

上面的图 G1 包含了 "A,B,C,D,E,F,G" 共 7 个顶点，而且包含了 "(A,C), (A,D), (A,F), (B,C), (C,D), (E,G), (F,G)"共 7 条边。右边的矩阵是 G1 在内存中的邻接表示意图，其中每一个顶点都包含一条链表，该链表记录了**"**该顶点的邻接点的序号**"**。

例如，第 2 个顶点（顶点 C）包含的链表所包含的节点的数据分别是"0,1,3"，而这"0,1,3"分别对应"A,B,D"的序号，"A,B,D"都是 C 的邻接点，就是通过这种方式记录图的信息的。

**有向图**

<div align="center"><img src="imgs/pic7.png" alt="pic7" style="zoom:80%;" /></div>

上面的图 G2 包含了 "A,B,C,D,E,F,G" 共 7 个顶点，而且包含了 "<A,B>, <B,C>, <B,E>, <B,F>, <C,E>, <D,C>, <E,B>, <E,D>, <F,G>"共 9 条边。上图右边的矩阵是 G2 在内存中的邻接表示意图，每一个顶点都包含一条链表，该链表 记录了*"*该顶点所对应的出边的另一个顶点的序号*"*。

例如，第 1 个顶点（顶点 B）包含的链表 所包含的节点的数据分别是"2,4,5"，而这"2,4,5"分别对应"C,E,F"的序号，"C,E,F"都属于B的 出边的另一个顶点。

​      

## 3. 遍历

2种遍历方式：DFS 和 BFS

   

### 1）深度优先遍历 DFS

**主要思想**：从图中某个顶点V0出发，访问此顶点，然后从V0 **邻接**且**未被访问** 的顶点W为初始顶点，再从W出发进行深度优先搜索，直至图中所有和V0有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问到，则另选图中一个未增访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问为止。

<div align="center"><img src="imgs/pic8.png" alt="pic8" style="zoom:80%;" /></div>

​    

**连通图**

> DFS搜索过程：从访问图中任意选某一个起始顶点v后，由v出发，访问它的任一邻接顶点w1；再w1出发，访问与w1邻接但还没访问过的顶点w2；然后从w2出发，进行类型访问，... ...如此进去下去，直至到达所有邻接顶点都被访问过的顶点u为止。
>
> 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点
>
> * 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；
> * 如果没有，就再退回一步进行搜索；
>
> 重复上述过程，直到连通图中所有顶点都被访问过为止

<div align="center"><img src="imgs/pic9.png" alt="pic9" style="zoom:80%;" /></div>

**非连通图**

> DFS搜索过程：在每个连通分量或每个强连通分量中任选一个顶点，进行深度优先搜索遍历，最后将每个连通分量或强连通分量的遍历结果合起来，则得到整个非连通图的遍历结果。
>
> 遍历算法实现与连通图的只有一点不同，即对所有顶点进行循环，反复调用连通图的深度优先搜索遍历算法即可。

<div align="center"><img src="imgs/pic10.png" alt="pic10" style="zoom:80%;" /></div>

​        

### 2）广度优先遍历 BFS

广度优先搜索算法（Breadth First Search），又称为"宽度优先搜索"或"横向优先搜索"，简称BFS。

**主要思想**：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得**先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问**，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。

广度优先搜索是一种 **分层的搜索过程**，每向前走一步可能访问一批顶点，不像深度优先 搜索那样有回退的情况。因此，广度优先搜索不是一个递归的过程，其算法也不是递归的，其过程类似于树的层次遍历。

<div align="center"><img src="imgs/pic11.png" alt="pic11" style="zoom:80%;" /></div>

​        

**连通图**

<div align="center"><img src="imgs/pic12.png" alt="pic12" style="zoom:80%;" /></div>

**非连通图**

<div align="center"><img src="imgs/pic13.png" alt="pic13" style="zoom:80%;" /></div>

​       

# 二 最小生成树 Prim & Kruskal

一个连通图的生成树是它的极小连通子图，在 n 个顶点的情况下，有 n-1 条边。也就是 说，生成树是对连通图而言的，是连通图的极小连通子图，包含图中的所有顶点，有且仅有 *n-1* 条边。

在图论中，我们常常将树定义为一个无回路连通图。对于一个带权的无回路连通图，其 每个生成树所有边上的权值之和不能不同，我们把所有边上权值之和最小的生成树称为图的 最小生成树。常见的求最小生成树的方法有两种：克鲁斯卡尔**(Kruskal)** 算法 和 普里姆(**Prim**) 算法。

> Q：那我们如何选择这 **n** 个顶点，使得这 **n** 个顶点组成的 **n-1** 条边的总长度最短呢?
>
> A：我们从顶点 1 开始，把顶点 1 加入生成树集合(顶点集合)，在一端以顶点 1 为端点的边 中，选择一条最短的，把另一个端点加入生成树;然后选择一条到生成树最短的边，把此时 这条边一个端点肯定在生成树中，把另一个端点也加入生成树。依次选择到生成树最短的 边......直到选择了 n-1 条边为止。



## 1. Prim算法

“加点法”，即每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点

> 1. 图的所有顶点集合为VV；初始令集合u={s}, v=V−uu={s}, v=V−u；
> 2. 在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中；
> 3. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。

由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge，用来维护集合v中每个顶点与集合u中最小代价边信息：

<div align="center"><img src="imgs/pic14.png" alt="pic14" style="zoom:80%;" /></div>

​      

## 2. Kruskal算法

“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。

> 1. 把图中的所有边按代价从小到大排序；
> 2. 把图中的n个顶点看成独立的n棵树组成的森林；
> 3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树；
> 4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

<div align="center"><img src="imgs/pic15.png" alt="pic15" style="zoom:80%;" /></div>

​      

# 三 最短路径

​    

# 四 拓扑排序



# 五 AOE & 关键路径





















