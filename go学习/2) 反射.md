反射是指在程序运行期对程序本身进行访问和修改的能力，即程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。

支持反射的语言可以在程序编译期将变量的反射信息，如 `字段名称`、`类型信息`、`结构体信息` 等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。

 

## 1 reflect 包

Go语言中的反射是由 reflect 包提供支持的，它定义了两个重要的类型 **Type** 和 **Value** 任意接口值在反射中都可以理解为由 **reflect.Type** 和 **reflect.Value** 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。

 

### 1）反射的类型对象（reflect.Type）

在Go语言程序中，使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息，下面通过示例来理解获取类型对象的过程：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var a int
    typeOfA := reflect.TypeOf(a)
    fmt.Println(typeOfA.Name(), typeOfA.Kind())
}
```

  

### 2）反射种类（Kind）

种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：

```go
const (
    Invalid Kind = iota  // 非法类型
    Bool                 // 布尔型
    Int                  // 有符号整型
    Int8                 // 有符号8位整型
    Int16                // 有符号16位整型
    Int32                // 有符号32位整型
    Int64                // 有符号64位整型
    Uint                 // 无符号整型
    Uint8                // 无符号8位整型
    Uint16               // 无符号16位整型
    Uint32               // 无符号32位整型
    Uint64               // 无符号64位整型
    Uintptr              // 指针
    Float32              // 单精度浮点数
    Float64              // 双精度浮点数
    Complex64            // 64位复数类型
    Complex128           // 128位复数类型
    Array                // 数组
    Chan                 // 通道
    Func                 // 函数
    Interface            // 接口
    Map                  // 映射
    Ptr                  // 指针
    Slice                // 切片
    String               // 字符串
    Struct               // 结构体
    UnsafePointer        // 底层指针
)
```

Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。

  

### 3）从类型对象中获取类型名称和种类

Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 **Name()** 方法，返回表示**类型名称的字符串**；类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。

```go
package main
import (
    "fmt"
    "reflect"
)
// 定义一个Enum类型
type Enum int
const (
    Zero Enum = 0
)
func main() {
    // 声明一个空结构体
    type cat struct {
    }
    // 获取结构体实例的反射类型对象
    typeOfCat := reflect.TypeOf(cat{})
    // 显示反射类型对象的名称和种类
    fmt.Println(typeOfCat.Name(), typeOfCat.Kind())
    
    // 获取Zero常量的反射类型对象
    typeOfA := reflect.TypeOf(Zero)
    // 显示反射类型对象的名称和种类
    fmt.Println(typeOfA.Name(), typeOfA.Kind())
}

// return
> cat struct
> Enum int
```

 

### 4）指针与指针指向的元素

Go语言程序中对指针获取反射对象时，可以通过 **reflect.Elem()** 方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个`*`操作

```go
// 声明一个空结构体
type cat struct {
}
// 创建cat的实例
ins := &cat{}

// 获取结构体实例的反射类型对象
typeOfCat := reflect.TypeOf(ins)
// 显示反射类型对象的名称和种类
fmt.Printf("name:'%v' kind:'%v'\n", typeOfCat.Name(), typeOfCat.Kind())

// 取类型的元素
typeOfCat = typeOfCat.Elem()
// 显示反射类型对象的名称和种类
fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())

// return
> name:'' kind:'ptr'
> element name: 'cat', element kind: 'struct'
```

  

### 5）使用反射获取结构体的成员类型

任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象 reflect.Type 的 **NumField()** 和 **Field()** 方法获得结构体成员的详细信息。与成员获取相关的 reflect.Type 的方法如下表所示：

* **Field(i int) StructField**: 根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机
* **NumField() int**: 返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机
* **FieldByName(name string) (StructField, bool)**: 根据给定字符串返回字符串对应的结构体字段的信息，没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机
* **FieldByIndex(index []int) StructField**: 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机
* **FieldByNameFunc(match func(string) bool) (StructField,bool)**: 根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机

  

StructField 的结构如下：

```go
type StructField struct {
    Name string          // 字段名
    PkgPath string       // 字段路径
    Type      Type       // 字段反射类型对象
    Tag       StructTag  // 字段的结构体标签
    Offset    uintptr    // 字段在结构体中的相对偏移
    Index     []int      // Type.FieldByIndex中的返回的索引值
    Anonymous bool       // 是否为匿名字段
}
```

   

### 6）反射获取值信息

当我们将一个接口值传递给一个 reflect.ValueOf 函数调用时，此调用返回的是代表着此接口值的动态值的一个 reflect.Value 值。

 

#### a. 使用反射值对象包装任意值

Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）

```go
value := reflect.ValueOf(rawValue)
```

reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息，其中 reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。

 

#### b. 从反射值对象获取被包装的值

从反射值对象（reflect.Value）中获取值的方法

```go
Interface() interface {}: 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型
Int() int64: 将值以 int 类型返回，所有有符号整型均可以此方式返回
Uint() uint64: 将值以 uint 类型返回，所有无符号整型均可以此方式返回
Float() float64: 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回
Bool() bool: 将值以 bool 类型返回
Bytes() []bytes: 将值以字节数组 []bytes 类型返回
String() string: 将值以字符串类型返回
```

 

```go
func main() {
    // 声明整型变量a并赋初值
    var a int = 1024
    // 获取变量a的反射值对象
    valueOfA := reflect.ValueOf(a)
  	
    // 获取interface{}类型的值, 通过类型断言转换
    var getA int = valueOfA.Interface().(int)
    
    // 获取64位的值, 强制类型转换为int类型
    var getA2 int = int(valueOfA.Int())
    fmt.Println(getA, getA2)
}

// return
> 1024 1024
```

 

### 7）IsNil()和IsValid()

反射值对象（reflect.Value）提供一系列方法进行零值和空判定：

```go
IsNil() bool: 返回值是否为 nil, 如果值类型不是通道（channel）、函数、接口、map、指针或 切片时, 发生 panic，类似于语言层的 v== nil操作
IsValid() bool	判断值是否有效, 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等
```

  

```go
func main() {
    // *int的空指针
    var a *int
    fmt.Println("var a *int:", reflect.ValueOf(a).IsNil())
    
  	// nil值
    fmt.Println("nil:", reflect.ValueOf(nil).IsValid())
  	
    // *int类型的空指针
    fmt.Println("(*int)(nil):", reflect.ValueOf((*int)(nil)).Elem().IsValid())
  	
    // 实例化一个结构体
    s := struct{}{}
    // 尝试从结构体中查找一个不存在的字段
    fmt.Println("不存在的结构体成员:", reflect.ValueOf(s).FieldByName("").IsValid())
  	
    // 尝试从结构体中查找一个不存在的方法
    fmt.Println("不存在的结构体方法:", reflect.ValueOf(s).MethodByName("").IsValid())
  	
    // 实例化一个map
    m := map[int]int{}
    // 尝试从map中查找一个不存在的键
    fmt.Println("不存在的键：", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid())
}

// return
> var a *int: true
> nil: false
> (*int)(nil): false
> 不存在的结构体成员: false
> 不存在的结构体方法: false
> 不存在的键： false
```

  

### 8）通过反射修改变量的值

使用 reflect.Value 取元素、取地址及修改值的属性方法请参考下表

```go
Elem() Value:	取值指向的元素值，类似于语言层*操作。当值类型不是指针或接口时发生宕机，空指针时返回 nil 的 Value
Addr() Value: 对可寻址的值返回其地址，类似于语言层&操作。当值不可寻址时发生宕机	
CanAddr() bool: 表示值是否可寻址
CanSet() bool: 返回值能否被修改, 要求值可寻址且是导出的字段
```

   

值修改相关方法：

```go
Setlnt(x int64): 使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机
SetUint(x uint64): 使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机
SetFloat(x float64): 使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机
SetBool(x bool): 使用 bool 设置值。当值的类型不是 bod 时会发生宕机
SetBytes(x []byte): 设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机
SetString(x string): 设置字符串值。当值的类型不是 string 时会发生宕机
```

以上方法，在 reflect.Value 的 CanSet 返回 false 仍然修改值时会发生宕机，在已知值的类型时，应尽量使用值对应类型的反射设置值。

​    

### 9）通过类型信息创建实例

当已知 reflect.Type 时，可以**动态地创建这个类型的实例**，实例的类型为指针。例如 reflect.Type 的类型为 int 时，创建 int 的指针，即`*int`，代码如下：

```go
func main() {
    var a int
    // 取变量a的反射类型对象
    typeOfA := reflect.TypeOf(a)
  	
    // 根据反射类型对象创建类型实例
    aIns := reflect.New(typeOfA)
    // 输出Value的类型和种类
    fmt.Println(aIns.Type(), aIns.Kind())
}

// return
> *int ptr
```

  

### 10）通过反射调用函数

如果反射值对象（reflect.Value）中值的类型为函数时，可以通过 reflect.Value 调用该函数。使用反射调用函数时，需要将**参数**使用反射值对象的切片 **[]reflect.Value** 构造后传入 Call() 方法中，调用完成时，函数的返回值通过 []reflect.Value 返回。

```go
// 普通函数
func add(a, b int) int {
    return a + b
}

func main() {
    // 将函数包装为反射值对象
    funcValue := reflect.ValueOf(add)
  	
    // 构造函数参数, 传入两个整型值
    paramList := []reflect.Value{reflect.ValueOf(10), reflect.ValueOf(20)}
  	
    // 反射调用函数
    retList := funcValue.Call(paramList)
  	
    // 获取第一个返回值, 取整数值
    fmt.Println(retList[0].Int())
}
```









