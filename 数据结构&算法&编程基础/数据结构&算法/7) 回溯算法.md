# 回溯算法（Backtracking）

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标，但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

回溯算法特征总结：

> 回溯算法就是一种暴力穷举算法
>
> 穷举的过程就是遍历一棵多叉树的过程
>
> 回溯算法的代码框架和多叉树遍历的代码框架类似

​          

回溯法解决的问题都可以抽象为树形结构，即所有回溯法的问题都可以抽象为树形结构，因为回溯法解决的都是**在集合中递归查找子集**，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一颗高度有限的树（**N 叉树**）：

> **组合问题**：N 个数里面按一定规则找出 k 个数的集合；
>
> **切割问题**：一个字符串按一定规则有几种切割方式；
>
> **子集问题**：一个 N 个数的集合里有多少符合条件的子集；
>
> **排列问题（强调顺序）**：N 个数按一定规则全排列，有几种排列方式；
>
> **棋盘问题**：N 皇后、解数独等等；

​        

# 一 算法思想

在包含问题的所有解的解空间树中，按照**深度优先搜索DFS**的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯（其实回溯法就是对隐式图的深度优先搜索算法）。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束，而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

回溯的处理思想，实际上一个类似 **枚举搜索**尝试过程，即枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，可以把问题求解的过程分为 **多个阶段**。每个阶段都会面对一个岔路口，因此可以先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。

​     

# 二 算法特征

1）**深度优先遍历（DFS）**：回溯算法一般采用 DFS 求解，因此满足递归的一般特征；

2）**子集**：回溯题目一般都要求求解所有的最优解，因此DFS 的终止条件就是判断是否得到了一个最优解，然后直接返回；

3）**遍历空间集**：在每一轮 DFS 中都需要遍历空间集，根据题目性质，有的需要从 0 开始，有的需要从当前位置开始；

4）**剪枝**：在遍历空间集的时候，需要优先将不符合条件的去除掉，不然会做很多无用的递归调用，导致超时；

5）**加入元素**：遍历空间集的时候，加入每一个元素，然后再 DFS；

6）**移除元素**：当一轮 DFS 达到终止条件结束的时候，说明当前选择已经完成，需要返回到上一轮做其他选择，因此需要将上一轮选择时加入的元素删除掉；

​      

**剪枝策略**：

> 就是在搜索过程中利用 **过滤条件** 来剪去完全不用考虑（已经判断这条路走下去得不到最优解）的搜索路径，从而 **避免了一些不必要的搜索**，大大优化了算法求解速度，还保证了结果的正确性。
>
> 应用到回溯算法中，就可以 **提前判断当前路径是否能产生结果集**，如果否，就可以提前回溯，而这也叫做 **可行性剪枝**。
>
> 另外还有一种叫做 **最优性剪枝**，每次记录当前得到的 **最优值**，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯，eg：分支限界算法。

​       

# 三 例题分析

因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意 **元素标记问题**

> 1）在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
>
> 2）但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

​      



