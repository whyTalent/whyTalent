# 算法思想

简单介绍编程算法题背后涉及到的常见算法思想

​       

# 一 分治算法（Divide and Conquer）

分治算法，即分而治之，是指将一个规模为N的问题分解为K个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解，比较经典的应用就是 **归并排序（Merge Sort）** 以及 **快速排序（Quick Sort）** 等。

​     

## 1 算法思想

1）`分解 Divide`：将要求解的较大规模的问题分割成 `k` 个更小规模的子问题；

2）`求解 Conquer`：对这 `k` 个子问题分别求解，若如果子问题的规模仍然不够小，则再划分为 `k` 个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止；

3）`合并 Merge`：将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解；

​    

实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序

> a）一定是先找到最小问题规模时的求解方法
>
> b）然后考虑随着问题规模增大时的求解方法
>
> c）找到求解的递归函数式后（各种规模或因子），设计递归程序即可

​     

## 2 算法特征

分治所能解决的问题一般具有以下几个特征：

1）该问题的规模缩小到一定的程度 **可以直接求解**，一般情况绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

2）该问题可以分解为若干个规模较小的相同问题，即该问题具有 **最优子结构性质**，是应用分治算法的前提，也是大多数问题可以满足的，此特征反映了 **递归思想** 的引用；

3）利用该问题分解出的子问题的解 **可以合并** 为该问题的解，即算法关键，**能否利用分治法完全取决于问题是否具有第三条特征，如果满足特征1和2，但特征3不满足，则可以考虑用贪心算法或动态规划法**；

4）问题所分解出的各个子问题是相互独立的，即 **子问题之间不包含公共的子问题**，这涉及到 **分治的效率**，如果各子问题是不独立的，则分治要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治，但 **一般用动态规划较好**；

​           

# 二 动态规划算法（Dynamic Programing）

**动态规划过程**：即每次决策依赖于当前状态，又随即引起状态的转移，且一个决策序列就是在变化的状态中产生出来的，所以这种 `多阶段最优化决策解决问题的过程` 就称为动态规划。

​         

## 1 基本思想

与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解，所以依次解决各子问题，最后一个子问题就是初始问题的解；

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中；

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的，即 ***下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解***；

​        

## 2 算法特征

可用于判断动态规划方法是否适用于给定的问题：

1）**最优子结构**：在自下而上的递推过程中，所求得的每个子问题一定是全局最优解，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是 `全局最优解`；

2）**无后效性**：是一个非常“宽松”的要求，只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性；

> 第一层含义：在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的；
>
> 第二层含义：某阶段状态一旦确定，就不受之后阶段的决策影响；

3）**重叠子问题**：在求解原问题的时候，往往需要依赖其子问题，子问题依赖其子子问题，甚至可能同时依赖多个子问题，因此子问题之间是有重叠关系的；

<div align="center"><img src="imgs/pic46.png" alt="pic46" style="zoom:80%;" /></div>

​      

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线），一般来说动态规划的设计都有着一定的模式，一般要经历以下几个步骤，如图所示：

> 初始状态 -> 决策 1 -> 决策 2 -> ... -> 决策 n -> 结束状态

实际应用中可以按以下几个简化的步骤进行设计题目：

> 1）分析最优解的性质，并刻画其结构特征
>
> 2）递归的定义最优解
>
> 3）以自底向上或自顶向下的记忆方式（备忘录法）计算出最优解
>
> 4）根据计算最优值时得到的消息，构造问题的最优解

​           

## 3 例题分析

DP问题解题套路：

> 明确状态 --> 明确选择 --> 明确 dp 函数/数组的定义 --> 明确 base case

​    

### 3.1 [爬楼梯](https://leetcode.com/problems/climbing-stairs/description/)

**问题**：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法

**解题思路**

Step1：明确 dp 数组的定义，即 dp[i] 表示走到第 i 个楼梯的方法数目

Step2：根据 **选择** 写出状态转移逻辑

> 第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和
>
> **dp[i] = dp[i-1] + dp[i-2]**
>
> 考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度
>
> ```go
> func ClimbStairs(N int) int {
> 	if N <= 2 {
> 		return N
> 	}
> 
> 	one, two := 1, 2
> 	for i := 2; i < N; i++ {
> 		cur := one + two
> 
> 		one, two = two, cur
> 	}
> 
> 	return two
> }
> ```

​       

### 3.2 0-1背包问题

**问题**：对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包 ***最大重量限制***  的前提下，背包中 ***物品总重量的最大价值*** 是多少呢？

```go
/**
weights 物品重量
* weights[i]  -> 第 i 件物品重量
values 物品价值
* values[i] -> 第 i 件物品价值
W 背包可承载重量
*/
func knapsack(weights []int, values []int, W int) int {}
```

​    

**解题思路**

Step1：明确 **状态** 和 **选择**

> `状态`：背包的空余容量剩多少 / 可选择的物品还有哪些
>
> `选择`：把这个物品装进背包 / 不把这个物品装进背包
>
> ```go
> // 初始化 base case
> dp[0][0][...] = base;
> 
> // 进行状态转移
> for 状态1 of 状态1的所有值 {
>   for 状态2 of 状态2的所有值 {
>     for ... {
>       dp[状态1][状态2][...] = 求最值(选择1, 选择2, ...)
>     }
>   }
> }
> ```

Step2：明确 dp 数组的定义

> `dp[i][j]` 含义：表示前 i 件物品容量不超过 j 的情况下能达到的最大价值，比如`dp[3][5] = 6` ，表示对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6；
>
> 根据此定义，还可得出 base case 为 **dp[0]\[..] = dp[..]\[0] = 0**，而最终计算得到结果为 **dp[N]\[w]**

Step3：根据 **选择** 写出状态转移逻辑

> 设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论
>
> * a）第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值，就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i]\[j] = dp[i-1]\[j]；
> * b）第 i 件物品添加到背包中，dp[i]\[j] = dp[i-1]\[j-w] + v
>
> 第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大，因此0-1 背包的状态转移方程为：
>
> **dp[i]\[j] = max(dp[i-1]\[j], dp[i-1]\[j-w] + v)**
>
> ```go
> func Knapsack(weights []int, values []int, W int) int {
> 	N := len(weights)
> 
> 	// init: dp[N + 1][W + 1]
> 	dp := make([][]int, N+1)
> 	for k := 0; k < N; k++ {
> 		dp[k] = make([]int, W+1)
> 	}
> 
> 	for i := 1; i <= N; i++ {
> 		w, v := weights[i-1], values[i-1]
> 		for j := 1; j <= W; j++ {
> 			// dp[i][j] = max(把物品 i 装进背包, 不把物品 i 装进背包)
> 			if j >= w {
> 				dp[i][j] = getMaxInt(dp[i-1][j], dp[i-1][j-w]+v)
> 			} else {
> 				dp[i][j] = dp[i-1][j]
> 			}
> 		}
> 	}
> 
> 	return dp[N][W]
> }
> 
> func getMaxInt(a, b int) int {
> 	if a > b {
> 		return a
> 	}
> 
> 	return b
> }
> ```



​              

# 三 贪心算法

贪心算法：又称贪婪算法，在对问题求解时，总是做出在当前看来时最好的选择，**本质是选择每一阶段的局部最优，从而达到全局最优**。

​     

## 1 算法思想

贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关，**所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。**

贪心算法和动态规划的对比：

> a. 贪心算法与动态规划的不同在于贪心算法对每个子问题的解决方案都做出选择，不能回退；
>
> b. 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

​        

## 2 算法特征

**贪心属性**：即每次迭代时都采用局部最优解，而无需考虑对全局的影响。相信通过不断求解局部最优解终会得到全局最优解，但是正如之前所说，这个结论不一定成立。为了证明在每次迭代终都求得了最优解，需要使用归纳法（显然不是简单的证明）；

**最优子结构**：求解的问题必须能划分为子问题，每个子问题都有最优解；





# 四 回溯算法（Backtracking）

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标，但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

回溯算法特征总结：

> 回溯算法就是一种暴力穷举算法
>
> 穷举的过程就是遍历一棵多叉树的过程
>
> 回溯算法的代码框架和多叉树遍历的代码框架类似

​          

回溯法解决的问题都可以抽象为树形结构，即所有回溯法的问题都可以抽象为树形结构，因为回溯法解决的都是**在集合中递归查找子集**，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一颗高度有限的树（**N 叉树**）：

> **组合问题**：N 个数里面按一定规则找出 k 个数的集合；
>
> **切割问题**：一个字符串按一定规则有几种切割方式；
>
> **子集问题**：一个 N 个数的集合里有多少符合条件的子集；
>
> **排列问题（强调顺序）**：N 个数按一定规则全排列，有几种排列方式；
>
> **棋盘问题**：N 皇后、解数独等等；

​        

## 1 算法思想

在包含问题的所有解的解空间树中，按照**深度优先搜索DFS**的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯（其实回溯法就是对隐式图的深度优先搜索算法）。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束，而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

回溯的处理思想，实际上一个类似 **枚举搜索**尝试过程，即枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，可以把问题求解的过程分为 **多个阶段**。每个阶段都会面对一个岔路口，因此可以先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。

​     

## 2 算法特征

1）**深度优先遍历（DFS）**：回溯算法一般采用 DFS 求解，因此满足递归的一般特征；

2）**子集**：回溯题目一般都要求求解所有的最优解，因此DFS 的终止条件就是判断是否得到了一个最优解，然后直接返回；

3）**遍历空间集**：在每一轮 DFS 中都需要遍历空间集，根据题目性质，有的需要从 0 开始，有的需要从当前位置开始；

4）**剪枝**：在遍历空间集的时候，需要优先将不符合条件的去除掉，不然会做很多无用的递归调用，导致超时；

5）**加入元素**：遍历空间集的时候，加入每一个元素，然后再 DFS；

6）**移除元素**：当一轮 DFS 达到终止条件结束的时候，说明当前选择已经完成，需要返回到上一轮做其他选择，因此需要将上一轮选择时加入的元素删除掉；

​      

**剪枝策略**：

> 就是在搜索过程中利用 **过滤条件** 来剪去完全不用考虑（已经判断这条路走下去得不到最优解）的搜索路径，从而 **避免了一些不必要的搜索**，大大优化了算法求解速度，还保证了结果的正确性。
>
> 应用到回溯算法中，就可以 **提前判断当前路径是否能产生结果集**，如果否，就可以提前回溯，而这也叫做 **可行性剪枝**。
>
> 另外还有一种叫做 **最优性剪枝**，每次记录当前得到的 **最优值**，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯，eg：分支限界算法。

​       

## 3 例题分析

因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意 **元素标记问题**

> 1）在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
>
> 2）但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

​      

### 3.1 N- Queens





