# 动态规划算法（Dynamic Programing）

**动态规划过程**：即每次决策依赖于当前状态，又随即引起状态的转移，且一个决策序列就是在变化的状态中产生出来的，所以这种 `多阶段最优化决策解决问题的过程` 就称为动态规划。

​         

# 一 基本思想

与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解，所以依次解决各子问题，最后一个子问题就是初始问题的解；

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中；

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的，即 ***下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解***；

​        

# 二 算法特征

可用于判断动态规划方法是否适用于给定的问题：

1）**最优子结构**：在自下而上的递推过程中，所求得的每个子问题一定是全局最优解，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是 `全局最优解`；

2）**无后效性**：是一个非常“宽松”的要求，只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性；

> 第一层含义：在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的；
>
> 第二层含义：某阶段状态一旦确定，就不受之后阶段的决策影响；

3）**重叠子问题**：在求解原问题的时候，往往需要依赖其子问题，子问题依赖其子子问题，甚至可能同时依赖多个子问题，因此子问题之间是有重叠关系的；

<div align="center"><img src="imgs/pic46.png" alt="pic46" style="zoom:80%;" /></div>

​      

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线），一般来说动态规划的设计都有着一定的模式，一般要经历以下几个步骤，如图所示：

> 初始状态 -> 决策 1 -> 决策 2 -> ... -> 决策 n -> 结束状态

实际应用中可以按以下几个简化的步骤进行设计题目：

> 1）分析最优解的性质，并刻画其结构特征
>
> 2）递归的定义最优解
>
> 3）以自底向上或自顶向下的记忆方式（备忘录法）计算出最优解
>
> 4）根据计算最优值时得到的消息，构造问题的最优解

​           

# 三 例题分析

DP问题解题套路：

> 明确状态 --> 明确选择 --> 明确 dp 函数/数组的定义 --> 明确 base case

​    

## 3.1 斐波那契数列

斐波那契数列（Fibonacci sequence），又称[黄金分割](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%2F115896)数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“[兔子数列](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97%2F6849441)”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……这个数列从第三项开始，每一项都等于前两项之和，其次裴波那契数列最具有和谐之美的地方是，越往后，相邻两项的比值会无限趋向于黄金比1:0.618。

<div align="center"><img src="imgs/pic48.png" alt="pic48" style="zoom:80%;" /></div>

在数学上，斐波那契数列以如下被以递推的方法定义：

> **f(1) = f(2) = 1**
>
> **f(n) = f(n - 1) + f(n - 2) （n>=3）**

​        

### 3.1.1 [爬楼梯](https://leetcode.com/problems/climbing-stairs/description/)

**问题**：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法

**解题思路**

Step1：明确 dp 数组的定义，即 dp[i] 表示走到第 i 个楼梯的方法数目

Step2：根据 **选择** 写出状态转移逻辑

> 第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和
>
> **dp[i] = dp[i-1] + dp[i-2]**
>
> 考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度

```go
func ClimbStairs(N int) int {
	if N <= 2 {
		return N
	}

	one, two := 1, 2
	for i := 2; i < N; i++ {
		cur := one + two

		one, two = two, cur
	}

	return two
}
```

​      

### 3.1.2 街区抢劫（[链形](https://leetcode.com/problems/house-robber/description/) & [环形](https://leetcode.com/problems/house-robber-ii/description/)）

**问题**：抢劫一排住户，但是不能抢邻近的住户（若抢劫相邻住户，则会触发报警），求可抢劫最大价值量

**解题思路**

Step1：明确 dp 数组的定义，即 dp[i] 表示抢到第 i 个住户时的最大抢劫量

Step2：根据 **选择** 写出状态转移逻辑

> 由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以强盗抢劫的最大量为
>
> **dp[i] = max(dp[i-2] + vaules[i], dp[i-1])**

```go
func RobInline(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	} else if n == 1 {
		return nums[0]
	}

	dp := make([]int, 2)
	dp[0], dp[1] = nums[0], getMaxInt(nums[0], nums[1])
	for i := 2; i < n; i++ {
		ind := i & 1  // i&1 == i%2, ind^1: 0->1, 1->0
		dp[ind] = getMaxInt(dp[ind]+nums[i], dp[ind^1])
	}

	return getMaxInt(dp[0], dp[1])
}
```

​      

**进阶**：若住户房屋呈 **环形**，则强盗可抢到的最大抢劫量是多少？

> 由于住户房屋呈 **环形**（首尾相接），则存在以下2种情况：
>
> * a）若抢了第1个住户，则不能抢最后一个住户（范围：1 ～ n-1）；
> * b）若没有抢第1个住户，则可抢最后一个住户（范围：2 ～ n）；
>
> 因此，基于原始强盗抢劫问题，可将问题分解成2个子问题，后对2个子问题结果进行比较返回最大值
>
> <div align="center"><img src="imgs/pic47.png" alt="pic47" style="zoom:60%;" /></div>

```go
func RobInCircle(nums []int) int {
   n := len(nums)
   if n == 0 {
      return 0
   } else if n == 1 {
      return nums[0]
   }

   return getMaxInt(RobInline(nums[:n-1]), RobInline(nums[1:]))
}
```

​      

### 3.1.3 [信件错排](https://leetcode.com/problems/find-the-derangement-of-an-array/)

**问题**：有 N 个 信 和 信封，顺序被打乱，求错误装信方式的数量

**解题思路**

Step1：明确 dp 数组存储错误方式的数量，即 dp[i] 表示前 i 个信和信封的错误方式数量

Step2：根据 **选择** 写出状态转移逻辑

>  对于第N封信而言，假设其装在了第 K 个信箱中，则对于第 K 封信，有两种情况：
>
> 1）**信件 K 装在信箱 N 中**：已经完成K和N两个信封，即若交换 K 和 N 的信后，它们的信和信封在正确的位置，其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 K 有 N-1 种取值，因此共有 **(N-1)*dp[N-2]** 种错误装信方式；
>
> <div align="center"><img src="imgs/pic49.png" alt="pic49" style="zoom:60%;" /></div>
>
> 2）**信件 K 未被装在信箱 N 中**：假设每个信封都有自己的专属信箱，N的专属信箱为K，那么可以认为K的专属信箱为N。但此场景下，信件 K 不能放入自己的专属信箱 N ，所以可以理解成求 N-1 封信件和 N-1 个信箱（除去信件 N）之间的错排数量问题，即求 dp[N-1]。由于 K 有 N-1 种取值，因此共有 (N-1)*dp[N-1] 种错误装信方式
>
> <div align="center"><img src="imgs/pic50.png" alt="pic50" style="zoom:60%;" /></div>

```go
func MailMissAlignment(n int) int {
	if n <= 1 {
		return 0
	}
	
	dp := make([]int, n)
	dp[0], dp[1] = 0, 1 // base case
	for i := 2; i < n; i++ {
		dp[i] = (i - 1) * (dp[i-2] + dp[i-1])
	}

	return dp[n-1]
}
```

​       

## 3.2 矩阵路径

### 3.2.1 [矩阵最小路径和](https://leetcode.com/problems/minimum-path-sum/description/)

**问题**：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动

<div align="center"><img src="imgs/pic51.png" alt="pic51" style="zoom:60%;" /></div>

**解题思路**

定义dp二维数组记录累加值，状态转移方程为：

`dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]`

```go
func MinPathSum(grid [][]int) int {
    row, col := len(grid), len(grid[0])
    if row == 0 || col == 0 {
        return 0
    }

    dp := make([][]int, row)
    for i:=0; i<row; i++ {
        dp[i] = make([]int, col)
    }

    dp[0][0] = grid[0][0]
    for i:=0; i<row; i++ {
        for j:=0; j<col; j++ {
            if i == 0 && j == 0 {
                continue
            }

            if i == 0 {
                dp[0][j] = dp[0][j-1] + grid[0][j]
            } else if j == 0 {
                dp[i][0] = dp[i-1][0] + grid[i][0]
            } else {
                dp[i][j] = getMinInt(dp[i][j-1], dp[i-1][j]) + grid[i][j]
            }
        }
    }

    return dp[row-1][col-1]
}
```

**进阶**：空间复杂度O(n)

**滚动数组**：因为i行依赖 i行和i - 1行，所以计算完i行覆盖i - 1行的值，不会影响最终结果

```go
func MinPathSum(grid [][]int) int {
    row, col := len(grid), len(grid[0])
    if row == 0 || col == 0 {
        return 0
    }

    dp := make([]int, col)

    dp[0] = grid[0][0]
    for i:=0; i<row; i++ {
        for j:=0; j<col; j++ {
            if i == 0 && j == 0 {
                continue
            }

            if i == 0 {          // 只能从上边界来
                dp[j] = dp[j-1] + grid[0][j]
            } else if j == 0 {   // 只能从左边界来
                dp[j] = dp[j] + grid[i][0]
            } else {
                dp[j] = getMinInt(dp[j-1], dp[j]) + grid[i][j]
            }
        }
    }

    return dp[col-1]
}
```

​          

### 3.2.2 矩阵总路径数（[无障碍](https://leetcode.com/problems/unique-paths/) & [有障碍](https://leetcode.com/problems/unique-paths-ii/)）

**问题**：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动

<div align="center"><img src="imgs/pic52.png" alt="pic52" style="zoom:60%;" /></div>

**解题思路**

dp[i]\[j] 表示从左上角(0, 0)到坐标为(i, j)的点的路径数，则状态转移方程为：

`dp[i][j] = dp[i - 1][j], dp[i][j - 1]`

```go
// 空间复杂度O(m*n)
func UniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i:=0; i<m; i++ {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }

    for j:=0; j<n; j++ {
        dp[0][j] = 1
    }

    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}

// 空间复杂度O(n)
func UniquePathsForOpt(m int, n int) int {
    dp := make([]int, n)
    for j:=0; j<n; j++ {
        dp[j] = 1
    }

    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            dp[j] += dp[j-1] 
        }
    }

    return dp[n-1]
}
```

**数学公式**：问题实际是一个组合问题，即从左上角(0, 0) 移动到右下角(m-1, n-1)，总共移动的次数 **S = m + n - 2**，向下移动的次数 **D = n - 1**

<div align="center"><img src="imgs/pic53.png" alt="pic53" style="zoom:60%;" /></div>

那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)

<div align="center"><img src="imgs/pic54.png" alt="pic54" style="zoom:80%;" /></div>

```go
func uniquePaths(m int, n int) int {
    s := m + n - 2  // 总共的移动次数
    d := n - 1      // 向下的移动次数
    res := 1
    for i:=1; i<=d; i++ {
        res = res * (s - d + i) / i
    }

    return res
}
```

​      

**进阶2**：矩阵中存在障碍物，若有障碍物，则无法通过，统计机器人从矩阵左上角到右下角的路径总数

<div align="center"><img src="imgs/pic55.png" alt="pic55" style="zoom:80%;" /></div>

```go
// 空间复杂度O(m*n)
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m, n := len(obstacleGrid), len(obstacleGrid[0])
    if m < 1 || n < 1 || obstacleGrid[0][0] == 1 {
        return 0
    }

    dp := make([][]int, m)
    for i:=0; i<m; i++ {
        dp[i] = make([]int, n)
    }

    dp[0][0] = 1
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if (i == 0 && j == 0) || obstacleGrid[i][j] != 0 {
                continue
            }

            if i == 0 {         // first row
                dp[0][j] = dp[0][j-1]
            } else if j == 0 {  // first col
                dp[i][0] = dp[i-1][0]
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[m-1][n-1]
}

// 空间复杂度O(n)
func UniquePathsWithObstaclesForOpt(obstacleGrid [][]int) int {
    m, n := len(obstacleGrid), len(obstacleGrid[0])
    if m < 1 || n < 1 || obstacleGrid[0][0] == 1 {
        return 0
    }

    dp := make([]int, n)    
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if obstacleGrid[i][j] == 1 {
                // has obstacle, no way passthrough
                dp[j] = 0
            } else if j > 0 {
                // dp[j] = dp[j] + dp[j - 1] ==> current cell = top cell + left cell
                dp[j] += dp[j-1]
            }
        }
    }

    return dp[n-1]
}
```

​      

## 3.3 数组区间

### 3.3.1 数组区间和

#### a. 数组Immutable（[一维](https://leetcode.com/problems/range-sum-query-immutable/description/) & [二维](https://leetcode.com/problems/range-sum-query-2d-immutable/)）

**问题**：已知一维数组nums，求区间 i ~ j 的和

**解题思路**

问题可以转换为 **sum[j] - sum[i-1]**，其中 sum[i] 为 0 ~ i 的和

```go
type NumArray struct {
    Sums []int
}

func Constructor(nums []int) NumArray {
    preSum := make([]int, len(nums)+1)

    preSum[0] = 0
    for i := 1; i< len(preSum) ; i++ {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    
    return NumArray{
        Sums : preSum,
    }
}


func (this *NumArray) SumRange(left int, right int) int {
    return this.Sums[right+1] - this.Sums[left]
}
```

​       

**问题进阶**：已知二维数组nums，求从左上角 (row1, col1) 到右下角  (row2, col2) **区域内数值之和**？

<div align="center"><img src="imgs/pic56.png" alt="pic56" style="zoom:80%;" /></div>

**解题思路**：

> 1）思路1：基于一维数组的思路，以 "行" 为粒度计算每一行在列区间 i ~ j 的和，即 **sum[r]\[j] - sum[r]\[i-1]**，最后统计 row1 ~ row2 行之和；
>
> ```go
> func Constructor(matrix [][]int) NumMatrix {
> 	m, n := len(matrix), len(matrix[0])
> 	if m < 1 || n < 0 {
> 		return NumMatrix2DImmutable{}
> 	}
> 
> 	// init
> 	preSums := make([][]int, m)
> 	for i := 0; i < m; i++ {
> 		preSums[i] = make([]int, n+1)
> 	}
> 	
> 	// calculate
> 	for i := 0; i < m; i++ {
> 		for j := 1; j <= n; j++ {
> 			preSums[i][j] = preSums[i][j-1] + matrix[i][j-1]
> 		}
> 	}
> 
> 	return NumMatrix2DImmutable{
> 		Sums: preSums,
> 	}
> }
> 
> func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
> 	sum := 0
> 	for i := row1; i <= row2; i++ {
> 		sum += this.Sums[i][col2+1] - this.Sums[i][col1]
> 	}
> 	
> 	return sum
> }
> ```
>
> 2）思路2：定义 sum[i]\[j]表示从(0, 0) 到 (i, j) 区域内所有元素和
>
> <div align="center"><img src="imgs/pic57.png" alt="pic57" style="zoom:80%;" /></div>
>
> ```go
> type NumMatrix struct {
>     Sums [][]int
> }
> 
> // Constructor dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + matrix[i-1][j-1]
> func Constructor(matrix [][]int) NumMatrix {
>     m, n := len(matrix), len(matrix[0])
>     if m < 1 || n < 1 {
>         return NumMatrix{}
>     }
> 
>     // init
>     preSums := make([][]int, m + 1)
>     for i:=0; i<=m; i++ {
>         preSums[i] = make([]int, n + 1)
>     }
> 
>     // calculate 
>     for i:=1; i<=m; i++ {
>         for j:=1; j<=n; j++ {
>             preSums[i][j] = preSums[i][j-1] + preSums[i-1][j] - preSums[i-1][j-1] + matrix[i-1][j-1]
>         }
>     }
> 
>     return NumMatrix {
>         Sums: preSums,s
>     }
> }  
> 
> // SumRegion 区域和: sum[r2+1][c2+1] - sum[r2+1][c1] - sum[r1][c2+1] + sum[r1][c1]
> func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
>     sum := this.Sums[row2+1][col2+1] - this.Sums[row2+1][col1] - this.Sums[row1][col2+1] + this.Sums[row1][col1]
> 
>     return sum
> }
> ```

​       

#### b. 数组Mutable（[一维](https://leetcode.com/problems/range-sum-query-mutable/) & [二维](https://leetcode.com/problems/range-sum-query-2d-mutable/)）

**问题**：给定一维数组nums，求区间 i ~ j 内元素的和，同时数组内元素可以被改变

> `Constructor(int[] nums)`：根据一维数组初始化类对象
>
> `update(int index, int val)` ：更新数组 nums[index] = val
>
> `sumRange(int left, int right)` ：返回数组在区间 [left, right] 的数值和，比如： `nums[left] + nums[left + 1] + ... + nums[right]`

​     

**解题思路**

> 1）动态规划思想，Constructor / sumRange 实现思路同 不可变数组，Sums[i] 存储数组区间 [0, i] 内值之和 
>
> ```go
> func (this *NumArray) Update(index int, val int)  {
>     oriNum, n := 0, len(this.Sums)
>     tmp := 0
>     for i:=index+1; i<n; i++ {
>         if i == index + 1 {
>           tmp = this.Sums[i-1] + val
>         } else {
>           tmp = this.Sums[i-1] + (this.Sums[i] - oriNum)
>         }
> 
>         oriNum = this.Sums[i]
>       	this.Sums[i] = tmp
>     }
> }
> ```
>
> 2）[二叉索引树BIT](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/?ref=lbp)
>
> <div align="center"><img src="imgs/binary-indexed-tree.png" alt="binary-indexed-tree" style="zoom:80%;" /></div>
>
> ```go
> type NumArray struct {
>     Tree, Nums []int
> } 
> 
> func lowbits(x int) int {
>     return x & (-x)
> }
> 
> // Constructor 初始化BIT
> func Constructor(nums []int) NumArray {
>     n := len(nums)
>     capacity, tree, newNums := n+1, make([]int, n+1), make([]int, n+1)
> 
>     // init binary index tree
>     for i:=1; i<=n; i++ {
>         // tree[i] = sum(A[i-2^k+1] + .., + A[i])
>         tree[i] += nums[i-1]
>         newNums[i] = nums[i-1]
>         for j:=i-2; j>=i-lowbits(i); j-- {
>             tree[i] += nums[j]
>         }
>     }
> 
>     return NumArray {
>         Tree: tree,
>         Nums: newNums,
>         Capacity: capacity,
>     }
> }
> 
> // Update 更新Origin数组某一下标值
> func (this *NumArray) Update(index int, val int)  {
>     index += 1
> 
>     diff := val - this.Nums[index]
>     this.Nums[index] = val
> 
>     for index < this.Capacity {
>         // update leaf node value
>         this.Tree[index] += diff
>         // update the parent node of current node
>         index += lowbits(index)
>     }
> }
> 
> // Query 查询区间[1, index]内元素之和
> func  (this *NumArray) Query(index int) int {
>     sum := 0
> 
>     // [1, index]
>     index += 1
>     for index > 0 {
>         sum += this.Tree[index]
>         index -= lowbits(index)
>     }
> 
>     return sum
> }
> 
> // SumRange 查询任意区间[left, right]内元素之和
> func (this *NumArray) SumRange(left int, right int) int {
>     return this.Query(right) - this.Query(left-1)
> }
> ```
>
> 3）[线段树](https://www.geeksforgeeks.org/segment-tree-range-minimum-query/?ref=lbp)
>
> <div align="center"><img src="imgs/segment-tree-build.png" alt="segment-tree-build" style="zoom:80%;" /></div>
>
> ```go
> type NumArray struct {
>     root *SegmentTreeNode
> }
> 
> type SegmentTreeNode struct {
>     start, end int
>     sum int
>     left, right *SegmentTreeNode
> }
> 
> func Constructor(nums []int) NumArray {
>     return NumArray {
>         root: BuildTree(nums, 0, len(nums)-1),
>     }
> }
> 
> func newSegmentTreeNode(start, end int) *SegmentTreeNode {
>     return &SegmentTreeNode {
>         start: start,
>         end: end,
>     }
> }
> 
> func BuildTree(nums[] int, start, end int) *SegmentTreeNode {
>     if start > end {
>         return nil
>     }
> 
>     root := newSegmentTreeNode(start, end)
>     if start == end {
>         root.sum = nums[start]
>     } else {
>         mid := start + (end - start) / 2
>         root.left = BuildTree(nums, start, mid)    // 左区间 [start, mid]
>         root.right = BuildTree(nums, mid + 1, end) // 左区间 [mid+1, end]
> 
>         // 父节点值 = 左右子节点值之和
> 		root.sum = root.left.sum + root.right.sum
>     }
> 
>     return root
> }
> 
> func (this *NumArray) Update(index int, val int)  {
>     UpdateTree(this.root, index, val)
> }
> 
> func UpdateTree(root *SegmentTreeNode, index int, val int)  {
>     // update leaf node
>     if root.start == root.end {
>         root.sum = val
>     } else {  // 遍历迭代
>       mid := root.start + (root.end-root.start)/2
>       if index <= mid {
>         UpdateTree(root.left, index, val)
>       } else {
>         UpdateTree(root.right, index, val)
>       }
> 		
>       // 更新父节点
>       root.sum = root.left.sum + root.right.sum
> 	}
> }
> 
> func (this *NumArray) SumRange(left int, right int) int {
>     return SumRangeTree(this.root, left, right)
> }
> 
> // 二叉树查找
> func SumRangeTree(root *SegmentTreeNode, start, end int) int {
>     if root.start == start && root.end == end {
>         return root.sum
>     }
> 
>     // binary search
>     mid := root.start + (root.end - root.start) / 2
>     if end <= mid { // 左子树
>         return SumRangeTree(root.left, start, end)
>     } else if start >= mid + 1 { // 右子树
>         return SumRangeTree(root.right, start, end)
>     } else {
>         return SumRangeTree(root.left, start, mid) + SumRangeTree(root.right, mid+1, end)
>     }
> }
> ```

​        

**进阶**：给定一个二维数组(矩阵)，需要查询它的某个子矩阵的元素的和，同时矩阵内的元素可以被改变

**解题思路**：基于[二维数组的BIT思路](https://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/?ref=lbp)







​       

## 3.4 背包问题

**问题**：对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包 ***最大重量限制***  的前提下，背包中 ***物品总重量的最大价值*** 是多少呢？

**解题思路**

Step1：明确 **状态** 和 **选择**

> `状态`：背包的空余容量剩多少 / 可选择的物品还有哪些
>
> `选择`：把这个物品装进背包 / 不把这个物品装进背包

Step2：明确 dp 数组的定义

> `dp[i][j]` 含义：表示前 i 件物品容量不超过 j 的情况下能达到的最大价值，比如`dp[3][5] = 6` ，表示对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6；
>
> 根据此定义，还可得出 base case 为 **dp[0]\[..] = dp[..]\[0] = 0**，而最终计算得到结果为 **dp[N]\[w]**

Step3：根据 **选择** 写出状态转移逻辑

> 设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论
>
> * a）第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值，就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i]\[j] = dp[i-1]\[j]；
> * b）第 i 件物品添加到背包中，dp[i]\[j] = dp[i-1]\[j-w] + v
>
> 第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大，因此0-1 背包的状态转移方程为：
>
> **dp[i]\[j] = max(dp[i-1]\[j], dp[i-1]\[j-w] + v)**

```go
func Knapsack(weights []int, values []int, W int) int {
	N := len(weights)

	// init: dp[N + 1][W + 1]
	dp := make([][]int, N+1)
	for k := 0; k < N; k++ {
		dp[k] = make([]int, W+1)
	}

	for i := 1; i <= N; i++ {
		w, v := weights[i-1], values[i-1]
		for j := 1; j <= W; j++ {
			// dp[i][j] = max(把物品 i 装进背包, 不把物品 i 装进背包)
			if j >= w {
				dp[i][j] = getMaxInt(dp[i-1][j], dp[i-1][j-w]+v)
			} else {
				dp[i][j] = dp[i-1][j]
			}
		}
	}

	return dp[N][W]
}
```

​              


