# 动态规划算法（Dynamic Programing）

**动态规划过程**：即每次决策依赖于当前状态，又随即引起状态的转移，且一个决策序列就是在变化的状态中产生出来的，所以这种 `多阶段最优化决策解决问题的过程` 就称为动态规划。

​         

# 一 基本思想

与分治法类似，也是**将待求解的问题分解为若干个子问题**（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解，所以依次解决各子问题，最后一个子问题就是初始问题的解；

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中；

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的，即 ***下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解***；

​        

# 二 算法特征

可用于判断动态规划方法是否适用于给定的问题：

1）**最优子结构**：在自下而上的递推过程中，所求得的每个子问题一定是全局最优解，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是 `全局最优解`；

2）**无后效性**：是一个非常“宽松”的要求，只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性；

> 第一层含义：在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的；
>
> 第二层含义：某阶段状态一旦确定，就不受之后阶段的决策影响；

3）**重叠子问题**：在求解原问题的时候，往往需要依赖其子问题，子问题依赖其子子问题，甚至可能同时依赖多个子问题，因此子问题之间是有重叠关系的；

<div align="center"><img src="imgs/pic46.png" alt="pic46" style="zoom:80%;" /></div>

​      

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线），一般来说动态规划的设计都有着一定的模式，一般要经历以下几个步骤，如图所示：

> 初始状态 -> 决策 1 -> 决策 2 -> ... -> 决策 n -> 结束状态

实际应用中可以按以下几个简化的步骤进行设计题目：

> 1）分析最优解的性质，并刻画其结构特征
>
> 2）递归的定义最优解
>
> 3）以自底向上或自顶向下的记忆方式（备忘录法）计算出最优解
>
> 4）根据计算最优值时得到的消息，构造问题的最优解

​           

# 三 例题分析

DP问题解题套路：

> 明确状态 --> 明确选择 --> 明确 dp 函数/数组的定义 --> 明确 base case

​    

## 3.1 斐波那契数列

斐波那契数列（Fibonacci sequence），又称[黄金分割](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%2F115896)数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“[兔子数列](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97%2F6849441)”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……这个数列从第三项开始，每一项都等于前两项之和，其次裴波那契数列最具有和谐之美的地方是，越往后，相邻两项的比值会无限趋向于黄金比1:0.618。

<div align="center"><img src="imgs/pic48.png" alt="pic48" style="zoom:80%;" /></div>

在数学上，斐波那契数列以如下被以递推的方法定义：

> **f(1) = f(2) = 1**
>
> **f(n) = f(n - 1) + f(n - 2) （n>=3）**

​        

### 3.1.1 [爬楼梯](https://leetcode.com/problems/climbing-stairs/description/)

**问题**：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法

**解题思路**

Step1：明确 dp 数组的定义，即 dp[i] 表示走到第 i 个楼梯的方法数目

Step2：根据 **选择** 写出状态转移逻辑

> 第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和
>
> **dp[i] = dp[i-1] + dp[i-2]**
>
> 考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度

```go
func ClimbStairs(N int) int {
	if N <= 2 {
		return N
	}

	one, two := 1, 2
	for i := 2; i < N; i++ {
		cur := one + two

		one, two = two, cur
	}

	return two
}
```

​      

### 3.1.2 街区抢劫（[链形](https://leetcode.com/problems/house-robber/description/) & [环形](https://leetcode.com/problems/house-robber-ii/description/)）

**问题**：抢劫一排住户，但是不能抢邻近的住户（若抢劫相邻住户，则会触发报警），求可抢劫最大价值量

**解题思路**

Step1：明确 dp 数组的定义，即 dp[i] 表示抢到第 i 个住户时的最大抢劫量

Step2：根据 **选择** 写出状态转移逻辑

> 由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以强盗抢劫的最大量为
>
> **dp[i] = max(dp[i-2] + vaules[i], dp[i-1])**

```go
func RobInline(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	} else if n == 1 {
		return nums[0]
	}

	dp := make([]int, 2)
	dp[0], dp[1] = nums[0], getMaxInt(nums[0], nums[1])
	for i := 2; i < n; i++ {
		ind := i & 1  // i&1 == i%2, ind^1: 0->1, 1->0
		dp[ind] = getMaxInt(dp[ind]+nums[i], dp[ind^1])
	}

	return getMaxInt(dp[0], dp[1])
}
```

​      

**进阶**：若住户房屋呈 **环形**，则强盗可抢到的最大抢劫量是多少？

> 由于住户房屋呈 **环形**（首尾相接），则存在以下2种情况：
>
> * a）若抢了第1个住户，则不能抢最后一个住户（范围：1 ～ n-1）；
> * b）若没有抢第1个住户，则可抢最后一个住户（范围：2 ～ n）；
>
> 因此，基于原始强盗抢劫问题，可将问题分解成2个子问题，后对2个子问题结果进行比较返回最大值
>
> <div align="center"><img src="imgs/pic47.png" alt="pic47" style="zoom:60%;" /></div>

```go
func RobInCircle(nums []int) int {
   n := len(nums)
   if n == 0 {
      return 0
   } else if n == 1 {
      return nums[0]
   }

   return getMaxInt(RobInline(nums[:n-1]), RobInline(nums[1:]))
}
```

​      

### 3.1.3 [信件错排](https://leetcode.com/problems/find-the-derangement-of-an-array/)

**问题**：有 N 个 信 和 信封，顺序被打乱，求错误装信方式的数量

**解题思路**

Step1：明确 dp 数组存储错误方式的数量，即 dp[i] 表示前 i 个信和信封的错误方式数量

Step2：根据 **选择** 写出状态转移逻辑

>  对于第N封信而言，假设其装在了第 K 个信箱中，则对于第 K 封信，有两种情况：
>
> 1）**信件 K 装在信箱 N 中**：已经完成K和N两个信封，即若交换 K 和 N 的信后，它们的信和信封在正确的位置，其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 K 有 N-1 种取值，因此共有 **(N-1)*dp[N-2]** 种错误装信方式；
>
> <div align="center"><img src="imgs/pic49.png" alt="pic49" style="zoom:60%;" /></div>
>
> 2）**信件 K 未被装在信箱 N 中**：假设每个信封都有自己的专属信箱，N的专属信箱为K，那么可以认为K的专属信箱为N。但此场景下，信件 K 不能放入自己的专属信箱 N ，所以可以理解成求 N-1 封信件和 N-1 个信箱（除去信件 N）之间的错排数量问题，即求 dp[N-1]。由于 K 有 N-1 种取值，因此共有 (N-1)*dp[N-1] 种错误装信方式
>
> <div align="center"><img src="imgs/pic50.png" alt="pic50" style="zoom:60%;" /></div>

```go
func MailMissAlignment(n int) int {
	if n <= 1 {
		return 0
	}
	
	dp := make([]int, n)
	dp[0], dp[1] = 0, 1 // base case
	for i := 2; i < n; i++ {
		dp[i] = (i - 1) * (dp[i-2] + dp[i-1])
	}

	return dp[n-1]
}
```

​       

## 3.2 矩阵路径

### 3.2.1 [矩阵最小路径和](https://leetcode.com/problems/minimum-path-sum/description/)

**问题**：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动

<div align="center"><img src="imgs/pic51.png" alt="pic51" style="zoom:60%;" /></div>

**解题思路**

定义dp二维数组记录累加值，状态转移方程为：

`dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]`

```go
func MinPathSum(grid [][]int) int {
    row, col := len(grid), len(grid[0])
    if row == 0 || col == 0 {
        return 0
    }

    dp := make([][]int, row)
    for i:=0; i<row; i++ {
        dp[i] = make([]int, col)
    }

    dp[0][0] = grid[0][0]
    for i:=0; i<row; i++ {
        for j:=0; j<col; j++ {
            if i == 0 && j == 0 {
                continue
            }

            if i == 0 {
                dp[0][j] = dp[0][j-1] + grid[0][j]
            } else if j == 0 {
                dp[i][0] = dp[i-1][0] + grid[i][0]
            } else {
                dp[i][j] = getMinInt(dp[i][j-1], dp[i-1][j]) + grid[i][j]
            }
        }
    }

    return dp[row-1][col-1]
}
```

**进阶**：空间复杂度O(n)

**滚动数组**：因为i行依赖 i行和i - 1行，所以计算完i行覆盖i - 1行的值，不会影响最终结果

```go
func MinPathSum(grid [][]int) int {
    row, col := len(grid), len(grid[0])
    if row == 0 || col == 0 {
        return 0
    }

    dp := make([]int, col)

    dp[0] = grid[0][0]
    for i:=0; i<row; i++ {
        for j:=0; j<col; j++ {
            if i == 0 && j == 0 {
                continue
            }

            if i == 0 {          // 只能从上边界来
                dp[j] = dp[j-1] + grid[0][j]
            } else if j == 0 {   // 只能从左边界来
                dp[j] = dp[j] + grid[i][0]
            } else {
                dp[j] = getMinInt(dp[j-1], dp[j]) + grid[i][j]
            }
        }
    }

    return dp[col-1]
}
```

​          

### 3.2.2 矩阵总路径数（[无障碍](https://leetcode.com/problems/unique-paths/) & [有障碍](https://leetcode.com/problems/unique-paths-ii/)）

**问题**：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动

<div align="center"><img src="imgs/pic52.png" alt="pic52" style="zoom:60%;" /></div>

**解题思路**

dp[i]\[j] 表示从左上角(0, 0)到坐标为(i, j)的点的路径数，则状态转移方程为：

`dp[i][j] = dp[i - 1][j], dp[i][j - 1]`

```go
// 空间复杂度O(m*n)
func UniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i:=0; i<m; i++ {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }

    for j:=0; j<n; j++ {
        dp[0][j] = 1
    }

    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}

// 空间复杂度O(n)
func UniquePathsForOpt(m int, n int) int {
    dp := make([]int, n)
    for j:=0; j<n; j++ {
        dp[j] = 1
    }

    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            dp[j] += dp[j-1] 
        }
    }

    return dp[n-1]
}
```

**数学公式**：问题实际是一个组合问题，即从左上角(0, 0) 移动到右下角(m-1, n-1)，总共移动的次数 **S = m + n - 2**，向下移动的次数 **D = n - 1**

<div align="center"><img src="imgs/pic53.png" alt="pic53" style="zoom:60%;" /></div>

那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)

<div align="center"><img src="imgs/pic54.png" alt="pic54" style="zoom:80%;" /></div>

```go
func uniquePaths(m int, n int) int {
    s := m + n - 2  // 总共的移动次数
    d := n - 1      // 向下的移动次数
    res := 1
    for i:=1; i<=d; i++ {
        res = res * (s - d + i) / i
    }

    return res
}
```

​      

**进阶2**：矩阵中存在障碍物，若有障碍物，则无法通过，统计机器人从矩阵左上角到右下角的路径总数

<div align="center"><img src="imgs/pic55.png" alt="pic55" style="zoom:80%;" /></div>

```go
// 空间复杂度O(m*n)
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m, n := len(obstacleGrid), len(obstacleGrid[0])
    if m < 1 || n < 1 || obstacleGrid[0][0] == 1 {
        return 0
    }

    dp := make([][]int, m)
    for i:=0; i<m; i++ {
        dp[i] = make([]int, n)
    }

    dp[0][0] = 1
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if (i == 0 && j == 0) || obstacleGrid[i][j] != 0 {
                continue
            }

            if i == 0 {         // first row
                dp[0][j] = dp[0][j-1]
            } else if j == 0 {  // first col
                dp[i][0] = dp[i-1][0]
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[m-1][n-1]
}

// 空间复杂度O(n)
func UniquePathsWithObstaclesForOpt(obstacleGrid [][]int) int {
    m, n := len(obstacleGrid), len(obstacleGrid[0])
    if m < 1 || n < 1 || obstacleGrid[0][0] == 1 {
        return 0
    }

    dp := make([]int, n)    
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if obstacleGrid[i][j] == 1 {
                // has obstacle, no way passthrough
                dp[j] = 0
            } else if j > 0 {
                // dp[j] = dp[j] + dp[j - 1] ==> current cell = top cell + left cell
                dp[j] += dp[j-1]
            }
        }
    }

    return dp[n-1]
}
```

​      

## 3.3 数组区间

### 3.3.1 数组区间和

#### a. 数组Immutable（[一维](https://leetcode.com/problems/range-sum-query-immutable/description/) & [二维](https://leetcode.com/problems/range-sum-query-2d-immutable/)）

**问题**：已知一维数组nums，求区间 i ~ j 的和

**解题思路**

问题可以转换为 **sum[j] - sum[i-1]**，其中 sum[i] 为 0 ~ i 的和

```go
type NumArray struct {
    Sums []int
}

func Constructor(nums []int) NumArray {
    preSum := make([]int, len(nums)+1)

    preSum[0] = 0
    for i := 1; i< len(preSum) ; i++ {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    
    return NumArray{
        Sums : preSum,
    }
}


func (this *NumArray) SumRange(left int, right int) int {
    return this.Sums[right+1] - this.Sums[left]
}
```

​       

**问题进阶**：已知二维数组nums，求从左上角 (row1, col1) 到右下角  (row2, col2) **区域内数值之和**？

<div align="center"><img src="imgs/pic56.png" alt="pic56" style="zoom:80%;" /></div>

**解题思路**：

> 1）思路1：基于一维数组的思路，以 "行" 为粒度计算每一行在列区间 i ~ j 的和，即 **sum[r]\[j] - sum[r]\[i-1]**，最后统计 row1 ~ row2 行之和；
>
> ```go
> func Constructor(matrix [][]int) NumMatrix {
> 	m, n := len(matrix), len(matrix[0])
> 	if m < 1 || n < 0 {
> 		return NumMatrix2DImmutable{}
> 	}
> 
> 	// init
> 	preSums := make([][]int, m)
> 	for i := 0; i < m; i++ {
> 		preSums[i] = make([]int, n+1)
> 	}
> 	
> 	// calculate
> 	for i := 0; i < m; i++ {
> 		for j := 1; j <= n; j++ {
> 			preSums[i][j] = preSums[i][j-1] + matrix[i][j-1]
> 		}
> 	}
> 
> 	return NumMatrix2DImmutable{
> 		Sums: preSums,
> 	}
> }
> 
> func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
> 	sum := 0
> 	for i := row1; i <= row2; i++ {
> 		sum += this.Sums[i][col2+1] - this.Sums[i][col1]
> 	}
> 	
> 	return sum
> }
> ```
>
> 2）思路2：定义 sum[i]\[j]表示从(0, 0) 到 (i, j) 区域内所有元素和
>
> <div align="center"><img src="imgs/pic57.png" alt="pic57" style="zoom:80%;" /></div>
>
> ```go
> type NumMatrix struct {
>     Sums [][]int
> }
> 
> // Constructor dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + matrix[i-1][j-1]
> func Constructor(matrix [][]int) NumMatrix {
>     m, n := len(matrix), len(matrix[0])
>     if m < 1 || n < 1 {
>         return NumMatrix{}
>     }
> 
>     // init
>     preSums := make([][]int, m + 1)
>     for i:=0; i<=m; i++ {
>         preSums[i] = make([]int, n + 1)
>     }
> 
>     // calculate 
>     for i:=1; i<=m; i++ {
>         for j:=1; j<=n; j++ {
>             preSums[i][j] = preSums[i][j-1] + preSums[i-1][j] - preSums[i-1][j-1] + matrix[i-1][j-1]
>         }
>     }
> 
>     return NumMatrix {
>         Sums: preSums,s
>     }
> }  
> 
> // SumRegion 区域和: sum[r2+1][c2+1] - sum[r2+1][c1] - sum[r1][c2+1] + sum[r1][c1]
> func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
>     sum := this.Sums[row2+1][col2+1] - this.Sums[row2+1][col1] - this.Sums[row1][col2+1] + this.Sums[row1][col1]
> 
>     return sum
> }
> ```

​       

#### b. 数组Mutable（[一维](https://leetcode.com/problems/range-sum-query-mutable/) & [二维](https://leetcode.com/problems/range-sum-query-2d-mutable/)）

**问题**：给定一维数组nums，求区间 i ~ j 内元素的和，同时数组内元素可以被改变

> `Constructor(int[] nums)`：根据一维数组初始化类对象
>
> `update(int index, int val)` ：更新数组 nums[index] = val
>
> `sumRange(int left, int right)` ：返回数组在区间 [left, right] 的数值和，比如： `nums[left] + nums[left + 1] + ... + nums[right]`

​     

**解题思路**

> 1）动态规划思想，Constructor / sumRange 实现思路同 不可变数组，Sums[i] 存储数组区间 [0, i] 内值之和 
>
> ```go
> func (this *NumArray) Update(index int, val int)  {
>     oriNum, n := 0, len(this.Sums)
>     tmp := 0
>     for i:=index+1; i<n; i++ {
>         if i == index + 1 {
>           tmp = this.Sums[i-1] + val
>         } else {
>           tmp = this.Sums[i-1] + (this.Sums[i] - oriNum)
>         }
> 
>         oriNum = this.Sums[i]
>       	this.Sums[i] = tmp
>     }
> }
> ```
>
> 2）[二叉索引树BIT](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/?ref=lbp)
>
> <div align="center"><img src="imgs/binary-indexed-tree.png" alt="binary-indexed-tree" style="zoom:80%;" /></div>
>
> ```go
> type NumArray struct {
>     Tree, Nums []int
> } 
> 
> func lowbits(x int) int {
>     return x & (-x)
> }
> 
> // Constructor 初始化BIT
> func Constructor(nums []int) NumArray {
>     n := len(nums)
>     capacity, tree, newNums := n+1, make([]int, n+1), make([]int, n+1)
> 
>     // init binary index tree
>     for i:=1; i<=n; i++ {
>         // tree[i] = sum(A[i-2^k+1] + .., + A[i])
>         tree[i] += nums[i-1]
>         newNums[i] = nums[i-1]
>         for j:=i-2; j>=i-lowbits(i); j-- {
>             tree[i] += nums[j]
>         }
>     }
> 
>     return NumArray {
>         Tree: tree,
>         Nums: newNums,
>         Capacity: capacity,
>     }
> }
> 
> // Update 更新Origin数组某一下标值
> func (this *NumArray) Update(index int, val int)  {
>     index += 1
> 
>     diff := val - this.Nums[index]
>     this.Nums[index] = val
> 
>     for index < this.Capacity {
>         // update leaf node value
>         this.Tree[index] += diff
>         // update the parent node of current node
>         index += lowbits(index)
>     }
> }
> 
> // Query 查询区间[1, index]内元素之和
> func  (this *NumArray) Query(index int) int {
>     sum := 0
> 
>     // [1, index]
>     index += 1
>     for index > 0 {
>         sum += this.Tree[index]
>         index -= lowbits(index)
>     }
> 
>     return sum
> }
> 
> // SumRange 查询任意区间[left, right]内元素之和
> func (this *NumArray) SumRange(left int, right int) int {
>     return this.Query(right) - this.Query(left-1)
> }
> ```
>
> 3）[线段树](https://www.geeksforgeeks.org/segment-tree-range-minimum-query/?ref=lbp)
>
> <div align="center"><img src="imgs/segment-tree-build.png" alt="segment-tree-build" style="zoom:80%;" /></div>
>
> ```go
> type NumArray struct {
>     root *SegmentTreeNode
> }
> 
> type SegmentTreeNode struct {
>     start, end int
>     sum int
>     left, right *SegmentTreeNode
> }
> 
> func Constructor(nums []int) NumArray {
>     return NumArray {
>         root: BuildTree(nums, 0, len(nums)-1),
>     }
> }
> 
> func newSegmentTreeNode(start, end int) *SegmentTreeNode {
>     return &SegmentTreeNode {
>         start: start,
>         end: end,
>     }
> }
> 
> func BuildTree(nums[] int, start, end int) *SegmentTreeNode {
>     if start > end {
>         return nil
>     }
> 
>     root := newSegmentTreeNode(start, end)
>     if start == end {
>         root.sum = nums[start]
>     } else {
>         mid := start + (end - start) / 2
>         root.left = BuildTree(nums, start, mid)    // 左区间 [start, mid]
>         root.right = BuildTree(nums, mid + 1, end) // 左区间 [mid+1, end]
> 
>         // 父节点值 = 左右子节点值之和
> 		root.sum = root.left.sum + root.right.sum
>     }
> 
>     return root
> }
> 
> func (this *NumArray) Update(index int, val int)  {
>     UpdateTree(this.root, index, val)
> }
> 
> func UpdateTree(root *SegmentTreeNode, index int, val int)  {
>     // update leaf node
>     if root.start == root.end {
>         root.sum = val
>     } else {  // 遍历迭代
>       mid := root.start + (root.end-root.start)/2
>       if index <= mid {
>         UpdateTree(root.left, index, val)
>       } else {
>         UpdateTree(root.right, index, val)
>       }
> 		
>       // 更新父节点
>       root.sum = root.left.sum + root.right.sum
> 	}
> }
> 
> func (this *NumArray) SumRange(left int, right int) int {
>     return SumRangeTree(this.root, left, right)
> }
> 
> // 二叉树查找
> func SumRangeTree(root *SegmentTreeNode, start, end int) int {
>     if root.start == start && root.end == end {
>         return root.sum
>     }
> 
>     // binary search
>     mid := root.start + (root.end - root.start) / 2
>     if end <= mid { // 左子树
>         return SumRangeTree(root.left, start, end)
>     } else if start >= mid + 1 { // 右子树
>         return SumRangeTree(root.right, start, end)
>     } else {
>         return SumRangeTree(root.left, start, mid) + SumRangeTree(root.right, mid+1, end)
>     }
> }
> ```

​        

**进阶**：给定一个二维数组(矩阵)，需要查询它的某个子矩阵的元素的和，同时矩阵内的元素可以被改变

**解题思路**：基于[二维数组的BIT思路](https://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/?ref=lbp)

​       

### 3.3.2 子数组Subarray

#### a. [子数组最大和](https://leetcode.com/problems/maximum-subarray/description/)

**题目**：输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值，要求时间复杂度为O(n)。

> 例如输入的数组为`1, -2, 3, 10, -4, 7, 2, -5`，和最大的子数组为`3, 10, -4, 7, 2`， 因此输出为该子数组的和18。

**解析**：此题计算的是「最大子数组和」，可使用一个「子数组」类题目的常见技巧，即在定义子问题的时候加上 **位于数组尾部** 的限制条件，即定义子问题 表示`nums[0..k)` 中，**以最后一个元素结尾的**最大子数组和」，那么原问题可以表示为：

<div align="center"><img src="imgs/subarray_dp.png" alt="subarray_dp" style="zoom:80%;" /></div>

在子问题中限制结果位于数组尾部，是为了**将当前的最优结果跟后面新加入的元素能够拼接起来**，如下图所示：

<div align="center"><img src="imgs/subarray_dp2.png" alt="subarray_dp2" style="zoom:80%;" /></div>

假设currSum为当前最大子数组的和，maxSum为最后要返回的最大子数组的和，则当往后扫描时

> a. 对第j+1个元素有两种选择：要么放入前面找到的子数组，要么做为新子数组的第一个元素，即如果currSum 加上当前元素a[j]后不小于a[j]，则令currSum 加上 a[j]，否则currSum重新赋值，置为下一个元素，即currSum = a[j]（即：**currSum = max(a[j], currSum + a[j])**）
>
> b. 同时，当currSum > maxSum，则更新maxSum = currSum，否则保持原值，不更新（即：**maxSum = max(maxSum, currSum)**）

```go
// Time Complexity : O(N), Space Complexity : O(N)
func maxSubArray(nums []int) int {
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    
    maxNum := dp[0]
    for i:=1; i<len(nums); i++ {
        // dp[i-1] > 0
        if dp[i-1] + nums[i] > nums[i] {
            dp[i] = dp[i-1] + nums[i]
        } else {
            dp[i] = nums[i]
        }

        if maxNum < dp[i] {
            maxNum = dp[i]
        }
    }

    return maxNum
}

// Time Complexity : O(N), Space Complexity : O(1)
func maxSubArray(nums []int) int {
    currNum, maxNum := 0, nums[0]

    for i:=0; i<len(nums); i++ {
        // currSum = max(nums[j], currSum + nums[j])
        if currNum + nums[i] > nums[i] {
            currNum += nums[i]
        } else {
            currNum = nums[i]
        }
      
				// maxSum = max(maxSum, currSum)
        if maxNum < currNum {
            maxNum = currNum
        }
    }

    return maxNum
}
```

​     

#### b. [子数组最大乘积](https://leetcode.com/problems/maximum-product-subarray/description/)

**题目**：给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积

**解析**：假设以第i个数结尾的连续子数组的最大乘积为 f_max(i)，对于以第i个数结尾的子数组来说，因为nums[i]有可能是正数，也有可能是负数，需要分两种情况来讨论：

> a. 如果nums[i]为整数，那么f_max(i) 要么等于 nums[i]，要么等于 `f_max(i-1) * nums[i]`，即 `f_max(i) = max(nums[i], f_max(i-1)*nums[i])`
>
> b. 如果如果nums[i]为负数，那么 f_max(i) 要么等于nums[i]，要么等于以它前一个位置结尾的最小值和nums[i]的乘积，因为一个负数乘以一个最小值，它的结果反而大。这里可假设以第i个数结尾的连续子数组的最小乘积为 f_min(i)，因此可以得出 `f_max(i) = max(nums[i],  f_min(i-1)*nums[i])`

<div align="center"><img src="imgs/subarray_dp3.png" alt="subarray_dp3" style="zoom:80%;" /></div>

综上所述，对于以第i个数结尾的连续子数组来说，需要维护两个状态，即最大乘积 f_max(i) 和 最小乘积f_min(i)，且状态转移方程为： 

> f_max(i) = max {f_max(i-1) * nums[i] , nums[i] , f_min(i-1) * nums[i]}
>
> f_min(i) = min {f_min(i-1) * nums[i], nums[i] , f_max(i-1) * nums[i]}

```go
func maxProduct(nums []int) int {
    n := len(nums)
    dp_max, dp_min := make([]int, n), make([]int, n)
    dp_max[0], dp_min[0] = nums[0], nums[0]

    maxP := nums[0]
    for i:=1; i<n; i++ {
        dp_max[i] = getMax(nums[i], getMax(dp_max[i-1]*nums[i], dp_min[i-1]*nums[i]))
        dp_min[i] = getMin(nums[i], getMin(dp_max[i-1]*nums[i], dp_min[i-1]*nums[i]))

        if maxP < dp_max[i] {
            maxP = dp_max[i]
        }
    }

    return maxP
}

/***
# python3
def maxProduct(self,nums):
  n=len(nums)
  dp_max=nums[:]
  dp_min=nums[:]
  for i in range(1,n):
    dp_max[i] = max(nums[i], dp_min[i-1] * nums[i], dp_max[i-1] * nums[i])
    dp_min[i] = min(nums[i], dp_min[i-1] * nums[i], dp_max[i-1] * nums[i])
		
  return max(dp_max)
***/
```

**优化**：

> 1. 令imax为当前最大值，则当前最大值为 imax = max(imax * nums[i], nums[i])
> 2. 由于存在负数，那么会导致最大的变最小的，最小的变最大的，因此还需要维护当前最小值imin，imin = min(imin * nums[i], nums[i])
> 3. 当负数出现时，则imax与imin进行交换再进行下一步计算

```go
func maxProduct(nums []int) int {
    // 阶段最大值, 阶段最小值, 结果最大值
    iMax, iMin, maxPro := 1, 1, math.MinInt
    for i:=0; i<len(nums); i++ {
        // 当遇到负数的时候进行交换，因为 阶段最小*负数 就变阶段最大了，反之同理
        if nums[i] < 0 {
            iMax, iMin = iMin, iMax
        }
        // 若最小值是本身则说明这个元素值比前面连续子数组的最小值还小。相当于重置了阶段最小值的起始位置
        iMax = getMax(iMax * nums[i], nums[i])
        iMin = getMin(iMin * nums[i], nums[i])
        // 对比阶段最大值和结果最大值
        maxPro = getMax(iMax, maxPro)
    }

    return maxPro
}
```

​       

#### c. [等差数列划分](https://leetcode.com/problems/arithmetic-slices/description/)

**题目**：如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。例如 [1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。计算一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数，其中 子数组是数组中的一个连续序列。

<div align="center"><img src="imgs/subarray_dp5.gif" alt="subarray_dp5" style="zoom:100%;" /></div>

**思路一**：因为是求等差数列，可以想到满足 `num[i]-num[i-1]=num[i-1]-num[i-2]`

状态定义：dp[i]表示以nums[i]结尾的，而且长度大于等于3的连续子数组（且是等差数列）的个数，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和：

> 如果 num[i] - num[i-1] = num[i-1]-num[i-2]，说明 num[i]能和前面构成等差数列，那么 dp[i] = dp[i-1] + 1;
>
> 如果 num[i] - num[i-1] != num[i-1]-num[i-2]，说明 num[i]不能和前面构成等差数列，所以 dp[i] = 0

**PS**：**为什么是以nums[i]结尾呢？**任何一个等差数列都会以某一个数结尾，连续子数组和子序列一般都定义成「以什么什么结尾」，不同规模的子问题的结果的联系比较容易找到

<div align="center"><img src="imgs/subarray_dp4.png" alt="subarray_dp4" style="zoom:100%;" /></div>

```go
func numberOfArithmeticSlices(nums []int) int {
    n := len(nums)
    if n < 3 {
        return 0
    }

    res := 0
    // dp[i]表示以nums[i]结尾的，而且长度大于等于3的连续子数组（且是等差数列）的个数
    dp := make([]int, n)
    for i:=2; i<n; i++ {
        // 等差数列判断条件
        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2] {
            dp[i] = dp[i-1] + 1
            res += dp[i]
        }
    }
		
    return res
}
```

​     

**思路二**：上述题目也可使用 “**双指针（滑动窗口）**”进行求解

即根据当前最长的连续等差数列的长度，可以计算出长度大于等于3的连续等差数列的长度，因此可以使用滑动窗口找到当前输入数组上的最长的连续等差数列的长度L，计算L对结果的贡献。

> 以数组[2, 4, 6, 8, 12, 16, 20]为例
>
> 已知 [2, 4, 6, 8] 是首项为 2 公差为 2 的等差数列时，加入 12 ，发现 [2, 4, 6, 8, 12] 不是等差数列，因此左端点是 2，右端点更靠右的所有连续子数组都不会是（以 2 开头）的等差数列，并且以 4、6 为起点连续子区间也不用看了，从 8 开始继续找（8 有可能是下一段等差数列的开头）
>
> 长度为 L 的等差数列对结果的贡献，可以举几个例子找规律，例如长度为 6 的等差数列对结果的贡献：
>
> * 长度为 3 的连续的等差数列，有 4 个，如下图绿色线段；
> * 长度为 4 的连续的等差数列，有 3 个，如下图黄色线段；
> * 长度为 5 的连续的等差数列，有 2 个，如下图红色线段；
> * 长度为 6 的连续的等差数列，有 1 个，如下图蓝色线段；
>
> <div align="center"><img src="imgs/subarray_dp6.png" alt="subarray_dp6" style="zoom:80%;" /></div>
>
> 因此，长度为 L 的等差数列对结果的贡献为：
>
> **(L - 2) + (L - 1) + ... ... + 2 + 1 = (L - 2 + 1) \* (L - 2) / 2 = (L - 1) \* (L - 2) / 2**
>
> **PS**：长度为 L的连续子序列中，长度为 3 的连续等差数列（下图中绿色线段）的个数为 L - 2 
>
> <div align="center"><img src="imgs/subarray_dp7.png" alt="subarray_dp7" style="zoom:100%;" /></div>
>
> 

```go
func numberOfArithmeticSlices(nums []int) int {
    n := len(nums)
    if n < 3 {
        return 0
    }
		
    res, L := 0, 0
    for i:=2; i<n; i++ {
        // 等差数列判断条件
        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2] {
            L++
        } else {
            res += (L + 1) * L / 2
            L = 0
        }
    }

    res += (L + 1) * L / 2

    return res
}
```

​         

#### d. [等差数列划分II -- 允许删除元素](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/description/)

**题目**：给定一个整数数组 nums ，返回 nums 中所有 等差子序列的数目。即如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

> 例如 [1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列，其次如果数组中的子序列可能是从数组中**删除一些元素**后得到的，例如 [2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。

**思路**：

题目要求求解等差子序列，若以 [1,2,3,4,5] 为例，[1,3,5]也是一个合格的答案，所以可以转换成 **求出每一个以nums[i]结尾的公差d的元素个数** ，再按照上述求等差子数组的思路很容易求出以nums[i]结尾等着为d的等差子数组的数量，把所有这些等差d加一起就是以nums[i]结尾的等差子序列的数量，列举所有的i即可求得结果，因此定义如下：

> **状态定义**：`dp[i][d]` 表示以nums[i]结尾，公差为d的等差子数组的数量
>
> **状态转移**：`dp[i][d] = dp[j][d] + 1` ，其中 j 表示以nums[i]结尾等着为d的前面那个数nums[j]的下标

这样定义看似没有问题，实际运行的过程其实是有问题的：

> **问题一**：以[1,2,3,4,5]为例，遍历到2（下标为1）的时候，它与下标0的元素1的差值为1，按照公式应该得到：`dp[1][1]=dp[0][1]+1=1`，但是这个结果并不符合题目的要求，题目要求长度至少为3，那么怎么才能知道下标j前面还有没有元素呢？如果只有 [nums[j], nums[i]] 是无法满足长度3的要求的；
>
> **问题二**：以 [7,7,7,7,7] 为例，遍历到第4个7（下标为3）的时候，它的等差子序列有4个，分别为`[7(0),7(1),7(3)]`、`[7(0),7(2),7(3)]`、`[7(1),7(2),7(3)]`、`[7(0),7(1),7(2),7(3)]`，按照`dp[i][d]=dp[j][d]+1` 的规则去计算也是不对的

再仔细想一下，既然三个长度的子序列是由两个长度的子序列升级来的，那么能不能在统计结果的时候从两个长度的子序列开始计算呢，这样三个长度的子序列就不用计算了，比如以[1,2,3,4,5]为例：

> 1）遍历到2时，以2结尾的子序列只有一个，即[1,2]，记为`dp[2][1]=1`；
>
> 2）遍历到3时，以3结尾的子序列有三个，分别为[1,2,3]、[1,3]、[2,3]，我们分别记为 `dp[3][1]=dp[2][1]+1=2` 和`dp[3][2]=dp[1][2]+1=1`  ，可以看到只有`dp[2][1]` 升级上来的那个子序列才可以作为结果，所以在这里 `ans += dp[2][1]`
>
> 3）遍历到4时，以4结尾的子序列有多少个呢？它与前面元素的公差分别有1、2、3，我们按照公式可得`dp[4][1]=dp[3][1]+1=3`、`dp[4][2]=dp[2][2]+1=1`、`dp[4][3]=dp[1][3]+1=1`，一共五个，分别是`[1,4]`、`[2,4]`、`[3,4]`、`[2,3,4]`、`[1,2,3,4]` ，可以看到只有`dp[3][1]`升级上来的那两个子序列才满足条件，所以 `ans += dp[3][1]`
>
> 4）再来看看[7,7,7,7,7]这种特殊用例，遍历到第4个7的时候，它与前面任意元素的差值都是0，按照前面的公式`dp[i][0]=dp[j][0]+1 `就不行了，这时候可以换成累加就可以轻松解决了，`dp[i][0]+=dp[j][0]+1`

最后，题目限定nums[i]的范围为`-2^31 <= nums[i] <= 2^31 - 1`，有可能溢出，而且也不知道等差d有多少个，所以使用**HashMap来存储key为公差的等差子数组数量**。

**DP 表**：hashMap

| 1    | 2               | 3                                | 4                                               | 5                                                            |
| ---- | --------------- | -------------------------------- | ----------------------------------------------- | ------------------------------------------------------------ |
|      | 1->1<br />{1,2} | 2->1<br />{1,3}                  | 3->1<br />{1,4}                                 | 4->1<br />{1,5}                                              |
|      |                 | **1->2**<br />{1,2,3}<br />{2,3} | 2->1<br />{2,4}                                 | 3->1<br />{2,5}                                              |
|      |                 |                                  | **1->3**<br />{1,2,3,4}<br />{2,3,4}<br />{3,4} | **2->2**<br />{1,3,5}<br />{3,5}                             |
|      |                 |                                  |                                                 | **1->4**<br />{1,2,3,4,5}<br />{2,3,4,5}<br />{3,4,5}<br />{4,5} |

实际可转换成

| hashMap映射表 | 子序列（等差数列）                      |
| :------------ | --------------------------------------- |
| **1->2**      | {1,2,3}                                 |
| **1->3**      | {1,2,3,4}<br />{2,3,4}                  |
| **2->2**      | {1,3,5}                                 |
| **1->4**      | {1,2,3,4,5}<br />{2,3,4,5}<br />{3,4,5} |

```go
func numberOfArithmeticSlices(nums []int) int {
    n := len(nums)
    if n < 3 {
        return 0
    }

    res := 0
    // 数组下标i与nums下标i一致，key表示每个等差d
    // 可以看成是等于dp[n][d]
    dp := make([]map[int]int, n)
    for i := range dp {
		  dp[i] = map[int]int{}
	  }

    for i:=0; i<n; i++ {
        for j:=0; j<i; j++ {
            // 求差值d, 注意可能溢出
            d := nums[j] - nums[i]
            // 结果为前面所有的长度大于等于2的子序列之和
            res += dp[j][d]
            // 计算dp[i][d]，可以看成dp[i][d]+=dp[j][d]+1
            dp[i][d] += dp[j][d] + 1
        }
    }

    return res
}
```

​        

## 3.4 分割整数





​       

## 3.5 背包问题

**问题**：对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包 ***最大重量限制***  的前提下，背包中 ***物品总重量的最大价值*** 是多少呢？

**解题思路**

Step1：明确 **状态** 和 **选择**

> `状态`：背包的空余容量剩多少 / 可选择的物品还有哪些
>
> `选择`：把这个物品装进背包 / 不把这个物品装进背包

Step2：明确 dp 数组的定义

> `dp[i][j]` 含义：表示前 i 件物品容量不超过 j 的情况下能达到的最大价值，比如`dp[3][5] = 6` ，表示对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6；
>
> 根据此定义，还可得出 base case 为 **dp[0]\[..] = dp[..]\[0] = 0**，而最终计算得到结果为 **dp[N]\[w]**

Step3：根据 **选择** 写出状态转移逻辑

> 设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论
>
> * a）第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值，就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i]\[j] = dp[i-1]\[j]；
> * b）第 i 件物品添加到背包中，dp[i]\[j] = dp[i-1]\[j-w] + v
>
> 第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大，因此0-1 背包的状态转移方程为：
>
> **dp[i]\[j] = max(dp[i-1]\[j], dp[i-1]\[j-w] + v)**

```go
func Knapsack(weights []int, values []int, W int) int {
	N := len(weights)

	// init: dp[N + 1][W + 1]
	dp := make([][]int, N+1)
	for k := 0; k < N; k++ {
		dp[k] = make([]int, W+1)
	}

	for i := 1; i <= N; i++ {
		w, v := weights[i-1], values[i-1]
		for j := 1; j <= W; j++ {
			// dp[i][j] = max(把物品 i 装进背包, 不把物品 i 装进背包)
			if j >= w {
				dp[i][j] = getMaxInt(dp[i-1][j], dp[i-1][j-w]+v)
			} else {
				dp[i][j] = dp[i-1][j]
			}
		}
	}

	return dp[N][W]
}
```

​              



# 附录

1. [OI Wiki](https://oi-wiki.org/dp/)
2. [geeksforgeeks - dp](https://www.geeksforgeeks.org/dynamic-programming/?ref=shm)
3. [Data Structure and Algorithms Guidebook](https://tsejx.github.io/data-structure-and-algorithms-guidebook//)
4. [Leetcode算法](http://www.leetcodecn.com/)
5. [Java 全栈知识体系](https://pdai.tech/)

